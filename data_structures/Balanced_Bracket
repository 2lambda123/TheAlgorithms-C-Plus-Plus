#include<iostream>
#include<string.h>
using namespace std;
class node{       
	public:
	char data;
	node* next;
	node(char x){
		data=x;
		next=NULL;
	}
};
class stack{        //stack implementation
	node* top;
	
	public:
	stack()
	{
		top=NULL;
	}
	int empty()
	{
		if(top==NULL)
		return 1;
		return 0;
	}
	void push(char x)
	{
		node *p;
		p=new node(x);
		p->next=top;
		top=p;		
	}
	char pop()
	{
		node *p;
		char x;
		if(!empty())
		{
			x=top->data;
			p=top;
			top=top->next;
			delete p;
			return x;
		}
		cout<<"invalid";
		return 0;
	}
};
char change(char compare)
{
	if(compare=='(')
	return ')';
	if(compare=='[')
	return ']';
	if(compare=='{')
	return '}';
}
int check(char string[])
{
	stack s;      //stack is used to put all type of opening braces in it
	char compare;
	for(int i=0;i<'\0';i++)
	{
		if(string[i]=='(' || string[i]=='[' || string[i]=='{')
		{
			s.push(string[i]);
		}
		if(string[i]==')' || string[i]==']' || string[i]=='}')
		{
			compare=s.pop();             // pops out the last opening brace
			compare=change(compare);     //  reverse that brace ex-> converts '(' to ')'
			if(string[i]!=compare)       //  if last opened brace type does not matches current closed brace will return 1;
			return 1;
		}		
	}
	return 0;
}
int main()
{	
	char string[50];   //input String
	cin.getline(string,48);
	if(!check(string))  //check
	cout<<"correctly paranthesis";
	else
	cout<<"Incorrectly paranthesis";
	
//	checkfirst(string);
//	checklast(string);
//	checknumber();
return 0;
}

