backtracking/knight_tour.cpp:59:16: style: The scope of the variable 'xnext' can be reduced. [variableScope]
    int k = 0, xnext = 0, ynext = 0;
               ^
backtracking/knight_tour.cpp:59:27: style: The scope of the variable 'ynext' can be reduced. [variableScope]
    int k = 0, xnext = 0, ynext = 0;
                          ^
backtracking/knight_tour.cpp:92:18: style: Variable 'j' is assigned a value that is never used. [unreadVariable]
    int i = 0, j = 0;
                 ^
backtracking/knight_tour.cpp:59:22: style: Variable 'xnext' is assigned a value that is never used. [unreadVariable]
    int k = 0, xnext = 0, ynext = 0;
                     ^
backtracking/knight_tour.cpp:59:33: style: Variable 'ynext' is assigned a value that is never used. [unreadVariable]
    int k = 0, xnext = 0, ynext = 0;
                                ^
backtracking/n_queens_all_solution_optimised.cpp:113:15: style: Condition 'n%2==0' is always true [knownConditionTrueFalse]
    if (n % 2 == 0) {
              ^
ciphers/a1z26_cipher.cpp:99:20: style: Local variable 'i' shadows outer variable [shadowVariable]
        for (auto& i : text_array) {
                   ^
ciphers/a1z26_cipher.cpp:89:16: note: Shadowed declaration
    for (auto& i : word_array) {
               ^
ciphers/a1z26_cipher.cpp:99:20: note: Shadow variable
        for (auto& i : text_array) {
                   ^
ciphers/atbash_cipher.cpp:50:16: style: Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]
        result += atbash_cipher_map[letter];
               ^
ciphers/uint256_t.hpp:34:15: style:inconclusive: Member variable 'uint256_t::f' is in the wrong place in the initializer list. [initializerList]
    uint128_t f{}, s{};  /// First and second half of 256 bit number
              ^
ciphers/uint256_t.hpp:75:41: note: Member variable 'uint256_t::f' is in the wrong place in the initializer list.
    explicit uint256_t(T low) : s(low), f(0) {}
                                        ^
ciphers/uint256_t.hpp:34:15: note: Member variable 'uint256_t::f' is in the wrong place in the initializer list.
    uint128_t f{}, s{};  /// First and second half of 256 bit number
              ^
ciphers/uint128_t.hpp:305:22: style:inconclusive: Technically the member function 'uint128_t::operator++' can be const. [functionConst]
    inline uint128_t operator++(int) {
                     ^
ciphers/uint128_t.hpp:352:22: style:inconclusive: Technically the member function 'uint128_t::operator--' can be const. [functionConst]
    inline uint128_t operator--(int p) {
                     ^
ciphers/uint128_t.hpp:574:17: style:inconclusive: Technically the member function 'uint128_t::operator<' can be const. [functionConst]
    inline bool operator<(const uint128_t &other) {
                ^
ciphers/uint128_t.hpp:583:17: style:inconclusive: Technically the member function 'uint128_t::operator<=' can be const. [functionConst]
    inline bool operator<=(const uint128_t &other) {
                ^
ciphers/uint128_t.hpp:592:17: style:inconclusive: Technically the member function 'uint128_t::operator>' can be const. [functionConst]
    inline bool operator>(const uint128_t &other) {
                ^
ciphers/uint128_t.hpp:601:17: style:inconclusive: Technically the member function 'uint128_t::operator>=' can be const. [functionConst]
    inline bool operator>=(const uint128_t &other) {
                ^
ciphers/uint128_t.hpp:610:17: style:inconclusive: Technically the member function 'uint128_t::operator==' can be const. [functionConst]
    inline bool operator==(const uint128_t &other) {
                ^
ciphers/uint128_t.hpp:619:17: style:inconclusive: Technically the member function 'uint128_t::operator!=' can be const. [functionConst]
    inline bool operator!=(const uint128_t &other) {
                ^
ciphers/uint128_t.hpp:627:17: style:inconclusive: Technically the member function 'uint128_t::operator!' can be const. [functionConst]
    inline bool operator!() { return !f && !s; }
                ^
ciphers/uint128_t.hpp:643:17: style:inconclusive: Technically the member function 'uint128_t::operator||' can be const. [functionConst]
    inline bool operator||(const uint128_t &b) {
                ^
ciphers/uint128_t.hpp:651:17: style:inconclusive: Technically the member function 'uint128_t::operator()' can be const. [functionConst]
    inline bool operator()() { return s || f; }
                ^
ciphers/uint128_t.hpp:746:17: style:inconclusive: Technically the member function 'uint128_t::operator||' can be const. [functionConst]
    inline bool operator||(const T b) {
                ^
ciphers/uint256_t.hpp:230:22: style:inconclusive: Technically the member function 'uint256_t::operator+' can be const. [functionConst]
    inline uint256_t operator+(const uint256_t &p) {
                     ^
ciphers/uint256_t.hpp:275:22: style:inconclusive: Technically the member function 'uint256_t::operator++' can be const. [functionConst]
    inline uint256_t operator++(int) {
                     ^
ciphers/uint256_t.hpp:298:22: style:inconclusive: Technically the member function 'uint256_t::operator-' can be const. [functionConst]
    inline uint256_t operator-(const uint256_t &p) {
                     ^
ciphers/uint256_t.hpp:322:22: style:inconclusive: Technically the member function 'uint256_t::operator--' can be const. [functionConst]
    inline uint256_t operator--(int p) {
                     ^
ciphers/uint256_t.hpp:543:17: style:inconclusive: Technically the member function 'uint256_t::operator<' can be const. [functionConst]
    inline bool operator<(const uint256_t &other) {
                ^
ciphers/uint256_t.hpp:552:17: style:inconclusive: Technically the member function 'uint256_t::operator<=' can be const. [functionConst]
    inline bool operator<=(const uint256_t &other) {
                ^
ciphers/uint256_t.hpp:561:17: style:inconclusive: Technically the member function 'uint256_t::operator>' can be const. [functionConst]
    inline bool operator>(const uint256_t &other) {
                ^
ciphers/uint256_t.hpp:570:17: style:inconclusive: Technically the member function 'uint256_t::operator>=' can be const. [functionConst]
    inline bool operator>=(const uint256_t &other) {
                ^
ciphers/uint256_t.hpp:579:17: style:inconclusive: Technically the member function 'uint256_t::operator==' can be const. [functionConst]
    inline bool operator==(const uint256_t &other) {
                ^
ciphers/uint256_t.hpp:588:17: style:inconclusive: Technically the member function 'uint256_t::operator!=' can be const. [functionConst]
    inline bool operator!=(const uint256_t &other) {
                ^
ciphers/uint256_t.hpp:596:17: style:inconclusive: Technically the member function 'uint256_t::operator!' can be const. [functionConst]
    inline bool operator!() { return !f && !s; }
                ^
ciphers/uint256_t.hpp:612:17: style:inconclusive: Technically the member function 'uint256_t::operator||' can be const. [functionConst]
    inline bool operator||(const uint256_t &b) {
                ^
ciphers/uint256_t.hpp:620:17: style:inconclusive: Technically the member function 'uint256_t::operator()' can be const. [functionConst]
    inline bool operator()() { return s || f; }
                ^
ciphers/uint256_t.hpp:715:17: style:inconclusive: Technically the member function 'uint256_t::operator||' can be const. [functionConst]
    inline bool operator||(const T &b) {
                ^
ciphers/uint256_t.hpp:723:22: style:inconclusive: Technically the member function 'uint256_t::operator~' can be const. [functionConst]
    inline uint256_t operator~() { return {~f, ~s}; }
                     ^
ciphers/uint256_t.hpp:865:22: style:inconclusive: Technically the member function 'uint256_t::operator|' can be const. [functionConst]
    inline uint256_t operator|(const uint256_t &p) {
                     ^
ciphers/uint256_t.hpp:910:22: style:inconclusive: Technically the member function 'uint256_t::operator^' can be const. [functionConst]
    inline uint256_t operator^(const uint256_t &p) {
                     ^
ciphers/elliptic_curve_key_exchange.cpp:55:17: style:inconclusive: Technically the member function 'ciphers::elliptic_curve_key_exchange::Point::operator==' can be const. [functionConst]
    inline bool operator==(const Point &p) { return x == p.x && y == p.y; }
                ^
ciphers/uint128_t.hpp:786:19: style: Condition 'p>=64' is always false [knownConditionTrueFalse]
            if (p >= 64 && p <= 128) {
                  ^
ciphers/uint128_t.hpp:785:13: note: Assuming condition 'p' is true
        if (p) {
            ^
ciphers/uint128_t.hpp:786:19: note: Condition 'p>=64' is always false
            if (p >= 64 && p <= 128) {
                  ^
ciphers/uint128_t.hpp:827:19: style: Condition 'p>=64' is always false [knownConditionTrueFalse]
            if (p >= 64) {
                  ^
ciphers/uint128_t.hpp:826:13: note: Assuming condition 'p' is true
        if (p) {
            ^
ciphers/uint128_t.hpp:827:19: note: Condition 'p>=64' is always false
            if (p >= 64) {
                  ^
ciphers/uint256_t.hpp:753:19: style: Condition 'p>=128' is always false [knownConditionTrueFalse]
            if (p >= 128) {
                  ^
ciphers/uint256_t.hpp:752:13: note: Assuming condition 'p' is true
        if (p) {
            ^
ciphers/uint256_t.hpp:753:19: note: Condition 'p>=128' is always false
            if (p >= 128) {
                  ^
ciphers/uint256_t.hpp:792:19: style: Condition 'p>=128' is always false [knownConditionTrueFalse]
            if (p >= 128) {
                  ^
ciphers/uint256_t.hpp:791:13: note: Assuming condition 'p' is true
        if (p) {
            ^
ciphers/uint256_t.hpp:792:19: note: Condition 'p>=128' is always false
            if (p >= 128) {
                  ^
ciphers/uint128_t.hpp:39:13: style: The scope of the variable 'sum' can be reduced. [variableScope]
    int16_t sum = 0, carry = 0;
            ^
ciphers/uint128_t.hpp:768:39: warning: Shifting 64-bit value by 64 bits is undefined behaviour. See condition at line 767. [shiftTooManyBits]
            return uint128_t((this->s << (p - 64)), 0);
                                      ^
ciphers/uint128_t.hpp:767:33: note: Assuming that condition 'p<=128' is not redundant
        } else if (p >= 64 && p <= 128) {
                                ^
ciphers/uint128_t.hpp:768:39: note: Shift
            return uint128_t((this->s << (p - 64)), 0);
                                      ^
ciphers/uint128_t.hpp:787:36: warning: Shifting 64-bit value by 64 bits is undefined behaviour. See condition at line 786. [shiftTooManyBits]
                this->f = (this->s << (p - 64));
                                   ^
ciphers/uint128_t.hpp:786:30: note: Assuming that condition 'p<=128' is not redundant
            if (p >= 64 && p <= 128) {
                             ^
ciphers/uint128_t.hpp:787:36: note: Shift
                this->f = (this->s << (p - 64));
                                   ^
ciphers/uint128_t.hpp:790:31: warning: Shifting 64-bit value by 129 bits is undefined behaviour. See condition at line 786. [shiftTooManyBits]
                f = ((this->f << p) + (this->s >> (64 - p)));
                              ^
ciphers/uint128_t.hpp:786:30: note: Assuming that condition 'p<=128' is not redundant
            if (p >= 64 && p <= 128) {
                             ^
ciphers/uint128_t.hpp:790:31: note: Shift
                f = ((this->f << p) + (this->s >> (64 - p)));
                              ^
ciphers/uint128_t.hpp:791:30: warning: Shifting 64-bit value by 129 bits is undefined behaviour. See condition at line 786. [shiftTooManyBits]
                s = (this->s << p);
                             ^
ciphers/uint128_t.hpp:786:30: note: Assuming that condition 'p<=128' is not redundant
            if (p >= 64 && p <= 128) {
                             ^
ciphers/uint128_t.hpp:791:30: note: Shift
                s = (this->s << p);
                             ^
ciphers/uint128_t.hpp:809:42: warning: Shifting 64-bit value by 64 bits is undefined behaviour. See condition at line 808. [shiftTooManyBits]
            return uint128_t(0, (this->f >> (p - 64)));
                                         ^
ciphers/uint128_t.hpp:808:33: note: Assuming that condition 'p<=128' is not redundant
        } else if (p >= 64 && p <= 128) {
                                ^
ciphers/uint128_t.hpp:809:42: note: Shift
            return uint128_t(0, (this->f >> (p - 64)));
                                         ^
ciphers/uint128_t.hpp:989:32: portability: Shifting signed 64-bit value by 63 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                if (p.s & (1LL << i)) {
                               ^
ciphers/uint128_t.hpp:995:32: portability: Shifting signed 64-bit value by 63 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                if (p.f & (1LL << i)) {
                               ^
ciphers/uint128_t.hpp:39:17: style: Variable 'sum' is assigned a value that is never used. [unreadVariable]
    int16_t sum = 0, carry = 0;
                ^
ciphers/hill_cipher.cpp:182:24: style: Unused private function: 'HillCipher::get_idx_char' [unusedPrivateFunction]
    static inline char get_idx_char(const uint8_t idx) { return STRKEY[idx]; }
                       ^
ciphers/hill_cipher.cpp:342:29: style: Variable 'min_mat' is assigned a value that is never used. [unreadVariable]
        matrix<int> min_mat = encrypt_key;
                            ^
ciphers/hill_cipher.cpp:381:19: style: Variable 'd2' is assigned a value that is never used. [unreadVariable]
        double d2 = determinant_lu(decrypt_key);
                  ^
ciphers/morse_code.cpp:207:24: style: Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]
        encrypted_text += ciphers::morse::char_to_morse(c) + " ";
                       ^
ciphers/morse_code.cpp:233:24: style: Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]
        decrypted_text += ciphers::morse::morse_to_char(s);
                       ^
cpu_scheduling_algorithms/fcfs_scheduling.cpp:277:34: warning: Assert statement calls a function which may have desired side effects: 'scheduleForFcfs'. [assertWithSideEffect]
        assert(res == readyQueue.scheduleForFcfs());
                                 ^
cpu_scheduling_algorithms/fcfs_scheduling.cpp:263:23: style: Local variable 'i' shadows outer variable [shadowVariable]
        for (uint32_t i{}; i < n; i++) {
                      ^
cpu_scheduling_algorithms/fcfs_scheduling.cpp:257:14: note: Shadowed declaration
    for (int i{}; i < 1000; i++) {
             ^
cpu_scheduling_algorithms/fcfs_scheduling.cpp:263:23: note: Shadow variable
        for (uint32_t i{}; i < n; i++) {
                      ^
cpu_scheduling_algorithms/fcfs_scheduling.cpp:271:23: style: Local variable 'i' shadows outer variable [shadowVariable]
        for (uint32_t i{}; i < n; i++) {
                      ^
cpu_scheduling_algorithms/fcfs_scheduling.cpp:257:14: note: Shadowed declaration
    for (int i{}; i < 1000; i++) {
             ^
cpu_scheduling_algorithms/fcfs_scheduling.cpp:271:23: note: Shadow variable
        for (uint32_t i{}; i < n; i++) {
                      ^
cpu_scheduling_algorithms/fcfs_scheduling.cpp:230:24: warning:inconclusive: Found suspicious operator '<' [constStatement]
    for (size_t i{}; i < input.size(); i++) {
                       ^
cpu_scheduling_algorithms/fcfs_scheduling.cpp:201:28: warning:inconclusive: Found suspicious operator '<' [constStatement]
        for (size_t i{}; i < result.size(); i++) {
                           ^
data_structures/binary_search_tree2.cpp:364:17: warning: Assert statement calls a function which may have desired side effects: 'find_max'. [assertWithSideEffect]
    assert(tree.find_max(max));
                ^
data_structures/binary_search_tree2.cpp:365:17: warning: Assert statement calls a function which may have desired side effects: 'find_min'. [assertWithSideEffect]
    assert(tree.find_min(min));
                ^
data_structures/binary_search_tree2.cpp:368:17: warning: Assert statement calls a function which may have desired side effects: 'size'. [assertWithSideEffect]
    assert(tree.size() == 1);
                ^
data_structures/binary_search_tree2.cpp:373:17: warning: Assert statement calls a function which may have desired side effects: 'find_max'. [assertWithSideEffect]
    assert(tree.find_max(max));
                ^
data_structures/binary_search_tree2.cpp:374:17: warning: Assert statement calls a function which may have desired side effects: 'find_min'. [assertWithSideEffect]
    assert(tree.find_min(min));
                ^
data_structures/binary_search_tree2.cpp:377:17: warning: Assert statement calls a function which may have desired side effects: 'size'. [assertWithSideEffect]
    assert(tree.size() == 4);
                ^
data_structures/binary_search_tree2.cpp:381:17: warning: Assert statement calls a function which may have desired side effects: 'size'. [assertWithSideEffect]
    assert(tree.size() == 4);
                ^
data_structures/binary_search_tree2.cpp:403:17: warning: Assert statement calls a function which may have desired side effects: 'find_max'. [assertWithSideEffect]
    assert(tree.find_max(max));
                ^
data_structures/binary_search_tree2.cpp:404:17: warning: Assert statement calls a function which may have desired side effects: 'find_min'. [assertWithSideEffect]
    assert(tree.find_min(min));
                ^
data_structures/binary_search_tree2.cpp:407:17: warning: Assert statement calls a function which may have desired side effects: 'size'. [assertWithSideEffect]
    assert(tree.size() == 3);
                ^
data_structures/binary_search_tree2.cpp:408:17: warning: Assert statement calls a function which may have desired side effects: 'contains'. [assertWithSideEffect]
    assert(tree.contains(5) == false);
                ^
data_structures/binary_search_tree2.cpp:413:17: warning: Assert statement calls a function which may have desired side effects: 'size'. [assertWithSideEffect]
    assert(tree.size() == 0);
                ^
data_structures/binary_search_tree2.cpp:414:17: warning: Assert statement calls a function which may have desired side effects: 'contains'. [assertWithSideEffect]
    assert(tree.contains(6) == false);
                ^
data_structures/binary_search_tree2.cpp:418:17: warning: Assert statement calls a function which may have desired side effects: 'size'. [assertWithSideEffect]
    assert(tree.size() == 0);
                ^
data_structures/binary_search_tree2.cpp:437:17: warning: Assert statement calls a function which may have desired side effects: 'contains'. [assertWithSideEffect]
    assert(tree.contains(5));
                ^
data_structures/binary_search_tree2.cpp:438:17: warning: Assert statement calls a function which may have desired side effects: 'contains'. [assertWithSideEffect]
    assert(tree.contains(4));
                ^
data_structures/binary_search_tree2.cpp:439:17: warning: Assert statement calls a function which may have desired side effects: 'contains'. [assertWithSideEffect]
    assert(tree.contains(3));
                ^
data_structures/binary_search_tree2.cpp:440:17: warning: Assert statement calls a function which may have desired side effects: 'contains'. [assertWithSideEffect]
    assert(tree.contains(6));
                ^
data_structures/binary_search_tree2.cpp:441:18: warning: Assert statement calls a function which may have desired side effects: 'contains'. [assertWithSideEffect]
    assert(!tree.contains(999));
                 ^
data_structures/binary_search_tree2.cpp:456:18: warning: Assert statement calls a function which may have desired side effects: 'find_min'. [assertWithSideEffect]
    assert(!tree.find_min(min));
                 ^
data_structures/binary_search_tree2.cpp:463:17: warning: Assert statement calls a function which may have desired side effects: 'find_min'. [assertWithSideEffect]
    assert(tree.find_min(min));
                ^
data_structures/binary_search_tree2.cpp:479:18: warning: Assert statement calls a function which may have desired side effects: 'find_max'. [assertWithSideEffect]
    assert(!tree.find_max(max));
                 ^
data_structures/binary_search_tree2.cpp:486:17: warning: Assert statement calls a function which may have desired side effects: 'find_max'. [assertWithSideEffect]
    assert(tree.find_max(max));
                ^
data_structures/binary_search_tree2.cpp:36:13: performance: Variable 'left' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
            left = nullptr;
            ^
data_structures/binary_search_tree2.cpp:37:13: performance: Variable 'right' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
            right = nullptr;
            ^
data_structures/binary_search_tree2.cpp:247:9: performance: Variable 'root_' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        root_ = nullptr;
        ^
data_structures/binary_search_tree2.cpp:313:17: style:inconclusive: Technically the member function 'binary_search_tree < int >::size' can be const. [functionConst]
    std::size_t size() { return size_; }
                ^
data_structures/binary_search_tree2.cpp:124:44: style: Parameter 'parent' can be declared with const [constParameter]
    bool remove(std::unique_ptr<bst_node>& parent,
                                           ^
data_structures/binaryheap.cpp:28:9: performance:inconclusive: Technically the member function 'MinHeap::parent' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    int parent(int i) { return (i - 1) / 2; }
        ^
data_structures/binaryheap.cpp:31:9: performance:inconclusive: Technically the member function 'MinHeap::left' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    int left(int i) { return (2 * i + 1); }
        ^
data_structures/binaryheap.cpp:34:9: performance:inconclusive: Technically the member function 'MinHeap::right' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    int right(int i) { return (2 * i + 2); }
        ^
data_structures/binaryheap.cpp:43:9: style:inconclusive: Technically the member function 'MinHeap::getMin' can be const. [functionConst]
    int getMin() { return harr[0]; }
        ^
data_structures/binaryheap.cpp:22:9: warning: Class 'MinHeap' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
        harr = new int[cap];
        ^
data_structures/binaryheap.cpp:22:9: warning: Class 'MinHeap' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
        harr = new int[cap];
        ^
data_structures/circular_queue_using_linked_list.cpp:41:10: style:inconclusive: Technically the member function 'Queue::traverse' can be const. [functionConst]
    void traverse() {
         ^
data_structures/cll/cll.h:21:10: style:inconclusive: Technically the member function 'cll::display' can be const. [functionConst]
    void display(); /* Show the list */
         ^
data_structures/cll/cll.cpp:17:11: note: Technically the member function 'cll::display' can be const.
void cll::display() {
          ^
data_structures/cll/cll.h:21:10: note: Technically the member function 'cll::display' can be const.
    void display(); /* Show the list */
         ^
data_structures/cll/cll.h:28:9: style:inconclusive: Technically the member function 'cll::get_size' can be const. [functionConst]
    int get_size();                   /* Get total element in list */
        ^
data_structures/cll/cll.cpp:74:10: note: Technically the member function 'cll::get_size' can be const.
int cll::get_size() { return total; }
         ^
data_structures/cll/cll.h:28:9: note: Technically the member function 'cll::get_size' can be const.
    int get_size();                   /* Get total element in list */
        ^
data_structures/cll/cll.h:29:10: style:inconclusive: Technically the member function 'cll::find_item' can be const. [functionConst]
    bool find_item(int item_to_find); /* Find an item in list */
         ^
data_structures/cll/cll.cpp:78:11: note: Technically the member function 'cll::find_item' can be const.
bool cll::find_item(int item_to_find) {
          ^
data_structures/cll/cll.h:29:10: note: Technically the member function 'cll::find_item' can be const.
    bool find_item(int item_to_find); /* Find an item in list */
         ^
data_structures/doubly_linked_list.cpp:14:10: performance:inconclusive: Technically the member function 'double_linked_list::insert' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void insert(int x);
         ^
data_structures/doubly_linked_list.cpp:21:26: note: Technically the member function 'double_linked_list::insert' can be static (but you may consider moving to unnamed namespace).
void double_linked_list::insert(int x) {
                         ^
data_structures/doubly_linked_list.cpp:14:10: note: Technically the member function 'double_linked_list::insert' can be static (but you may consider moving to unnamed namespace).
    void insert(int x);
         ^
data_structures/doubly_linked_list.cpp:15:10: performance:inconclusive: Technically the member function 'double_linked_list::remove' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void remove(int x);
         ^
data_structures/doubly_linked_list.cpp:41:26: note: Technically the member function 'double_linked_list::remove' can be static (but you may consider moving to unnamed namespace).
void double_linked_list::remove(int x) {
                         ^
data_structures/doubly_linked_list.cpp:15:10: note: Technically the member function 'double_linked_list::remove' can be static (but you may consider moving to unnamed namespace).
    void remove(int x);
         ^
data_structures/doubly_linked_list.cpp:16:10: performance:inconclusive: Technically the member function 'double_linked_list::search' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void search(int x);
         ^
data_structures/doubly_linked_list.cpp:65:26: note: Technically the member function 'double_linked_list::search' can be static (but you may consider moving to unnamed namespace).
void double_linked_list::search(int x) {
                         ^
data_structures/doubly_linked_list.cpp:16:10: note: Technically the member function 'double_linked_list::search' can be static (but you may consider moving to unnamed namespace).
    void search(int x);
         ^
data_structures/doubly_linked_list.cpp:17:10: performance:inconclusive: Technically the member function 'double_linked_list::show' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void show();
         ^
data_structures/doubly_linked_list.cpp:81:26: note: Technically the member function 'double_linked_list::show' can be static (but you may consider moving to unnamed namespace).
void double_linked_list::show() {
                         ^
data_structures/doubly_linked_list.cpp:17:10: note: Technically the member function 'double_linked_list::show' can be static (but you may consider moving to unnamed namespace).
    void show();
         ^
data_structures/doubly_linked_list.cpp:18:10: performance:inconclusive: Technically the member function 'double_linked_list::reverseShow' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void reverseShow();
         ^
data_structures/doubly_linked_list.cpp:89:26: note: Technically the member function 'double_linked_list::reverseShow' can be static (but you may consider moving to unnamed namespace).
void double_linked_list::reverseShow() {
                         ^
data_structures/doubly_linked_list.cpp:18:10: note: Technically the member function 'double_linked_list::reverseShow' can be static (but you may consider moving to unnamed namespace).
    void reverseShow();
         ^
data_structures/dsu_path_compression.cpp:178:18: warning: Assert statement calls a function which may have desired side effects: 'get'. [assertWithSideEffect]
        assert(d.get(4).at(i) == ans[i]);  // makes sure algorithm works fine
                 ^
data_structures/dsu_path_compression.cpp:196:18: warning: Assert statement calls a function which may have desired side effects: 'get'. [assertWithSideEffect]
        assert(d.get(3).at(i) == ans[i]);  // makes sure algorithm works fine
                 ^
data_structures/dsu_union_rank.cpp:148:18: warning: Assert statement calls a function which may have desired side effects: 'getParents'. [assertWithSideEffect]
        assert(d.getParents(7).at(i) ==
                 ^
data_structures/dsu_union_rank.cpp:173:18: warning: Assert statement calls a function which may have desired side effects: 'getParents'. [assertWithSideEffect]
        assert(d.getParents(2).at(i) ==
                 ^
data_structures/dsu_union_rank.cpp:61:14: style:inconclusive: Technically the member function 'dsu::findSet' can be const. [functionConst]
    uint64_t findSet(uint64_t i) {
             ^
data_structures/dsu_union_rank.cpp:119:22: style:inconclusive: Technically the member function 'dsu::getParents' can be const. [functionConst]
    vector<uint64_t> getParents(uint64_t i) {
                     ^
data_structures/linked_list.cpp:91:9: performance: Variable 'first' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        first = std::make_shared<link>();
        ^
data_structures/linked_list.cpp:93:9: performance: Variable 'last' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        last = nullptr;
        ^
data_structures/linked_list.cpp:63:9: style:inconclusive: Technically the member function 'data_structures::linked_list::link::val' can be const. [functionConst]
    int val() { return pvalue; }
        ^
data_structures/linked_list.cpp:96:10: style:inconclusive: Technically the member function 'data_structures::linked_list::list::isEmpty' can be const. [functionConst]
    bool isEmpty();
         ^
data_structures/linked_list.cpp:111:12: note: Technically the member function 'data_structures::linked_list::list::isEmpty' can be const.
bool list::isEmpty() {
           ^
data_structures/linked_list.cpp:96:10: note: Technically the member function 'data_structures::linked_list::list::isEmpty' can be const.
    bool isEmpty();
         ^
data_structures/list_array.cpp:241:14: warning: Assert statement calls a function which may have desired side effects: 'search'. [assertWithSideEffect]
    assert(L.search(11) == 0);  // search for the existing element
             ^
data_structures/list_array.cpp:242:14: warning: Assert statement calls a function which may have desired side effects: 'search'. [assertWithSideEffect]
    assert(L.search(12) == 2);
             ^
data_structures/list_array.cpp:243:14: warning: Assert statement calls a function which may have desired side effects: 'search'. [assertWithSideEffect]
    assert(L.search(50) == -1);  // search for the non-existing element
             ^
data_structures/list_array.cpp:251:14: warning: Assert statement calls a function which may have desired side effects: 'search'. [assertWithSideEffect]
    assert(L.search(11) == 1);  // search for the existing element
             ^
data_structures/list_array.cpp:252:14: warning: Assert statement calls a function which may have desired side effects: 'search'. [assertWithSideEffect]
    assert(L.search(12) == 2);
             ^
data_structures/list_array.cpp:253:14: warning: Assert statement calls a function which may have desired side effects: 'search'. [assertWithSideEffect]
    assert(L.search(50) == -1);  // search for the non-existing element
             ^
data_structures/list_array.cpp:203:10: style:inconclusive: Technically the member function 'list < 50 >::show' can be const. [functionConst]
    void show() {
         ^
data_structures/queue_using_linkedlist.cpp:18:10: style:inconclusive: Technically the member function 'stack_linkedList::display' can be const. [functionConst]
    void display();
         ^
data_structures/queue_using_linkedlist.cpp:47:24: note: Technically the member function 'stack_linkedList::display' can be const.
void stack_linkedList::display() {
                       ^
data_structures/queue_using_linkedlist.cpp:18:10: note: Technically the member function 'stack_linkedList::display' can be const.
    void display();
         ^
data_structures/queue_using_linkedlist.cpp:45:12: error: Uninitialized variable: ele [uninitvar]
    return ele;
           ^
data_structures/queue_using_linkedlist.cpp:45:12: error: Uninitialized variable: ele [uninitvar]
    return ele;
           ^
data_structures/queue_using_linkedlist.cpp:35:15: note: Assuming condition is true
    if (front == NULL)
              ^
data_structures/queue_using_linkedlist.cpp:45:12: note: Uninitialized variable: ele
    return ele;
           ^
data_structures/queue_using_two_stacks.cpp:108:16: warning: Assert statement calls a function which may have desired side effects: 'pop'. [assertWithSideEffect]
    assert(que.pop() == 2);
               ^
data_structures/queue_using_two_stacks.cpp:110:16: warning: Assert statement calls a function which may have desired side effects: 'pop'. [assertWithSideEffect]
    assert(que.pop() == 5);
               ^
data_structures/queue_using_two_stacks.cpp:112:16: warning: Assert statement calls a function which may have desired side effects: 'pop'. [assertWithSideEffect]
    assert(que.pop() == 0);
               ^
data_structures/queue_using_two_stacks.cpp:120:16: warning: Assert statement calls a function which may have desired side effects: 'pop'. [assertWithSideEffect]
    assert(que.pop() == -1);
               ^
data_structures/queue_using_two_stacks.cpp:130:17: warning: Assert statement calls a function which may have desired side effects: 'pop'. [assertWithSideEffect]
    assert(que2.pop() == 2.31223);
                ^
data_structures/queue_using_two_stacks.cpp:132:17: warning: Assert statement calls a function which may have desired side effects: 'pop'. [assertWithSideEffect]
    assert(que2.pop() == 3.1415926);
                ^
data_structures/queue_using_two_stacks.cpp:134:17: warning: Assert statement calls a function which may have desired side effects: 'pop'. [assertWithSideEffect]
    assert(que2.pop() == 2.92);
                ^
data_structures/rb_tree.cpp:32:7: style:inconclusive: Technically the member function 'RBtree::search' can be const. [functionConst]
 void search();
      ^
data_structures/rb_tree.cpp:421:14: note: Technically the member function 'RBtree::search' can be const.
void RBtree::search()
             ^
data_structures/rb_tree.cpp:32:7: note: Technically the member function 'RBtree::search' can be const.
 void search();
      ^
data_structures/rb_tree.cpp:36:11: style: Variable 'i' is assigned a value that is never used. [unreadVariable]
 int z, i = 0;
          ^
data_structures/reverse_a_linked_list.cpp:183:14: warning: Assert statement calls a function which may have desired side effects: 'top'. [assertWithSideEffect]
    assert(L.top() == 11);
             ^
data_structures/reverse_a_linked_list.cpp:184:14: warning: Assert statement calls a function which may have desired side effects: 'last'. [assertWithSideEffect]
    assert(L.last() == 18);
             ^
data_structures/reverse_a_linked_list.cpp:187:14: warning: Assert statement calls a function which may have desired side effects: 'top'. [assertWithSideEffect]
    assert(L.top() == 18);
             ^
data_structures/reverse_a_linked_list.cpp:188:14: warning: Assert statement calls a function which may have desired side effects: 'traverse'. [assertWithSideEffect]
    assert(L.traverse(1) == -20);
             ^
data_structures/reverse_a_linked_list.cpp:189:14: warning: Assert statement calls a function which may have desired side effects: 'traverse'. [assertWithSideEffect]
    assert(L.traverse(2) == -12);
             ^
data_structures/reverse_a_linked_list.cpp:190:14: warning: Assert statement calls a function which may have desired side effects: 'traverse'. [assertWithSideEffect]
    assert(L.traverse(3) == 10);
             ^
data_structures/reverse_a_linked_list.cpp:191:14: warning: Assert statement calls a function which may have desired side effects: 'traverse'. [assertWithSideEffect]
    assert(L.traverse(4) == 15);
             ^
data_structures/reverse_a_linked_list.cpp:192:14: warning: Assert statement calls a function which may have desired side effects: 'traverse'. [assertWithSideEffect]
    assert(L.traverse(5) == 12);
             ^
data_structures/reverse_a_linked_list.cpp:193:14: warning: Assert statement calls a function which may have desired side effects: 'last'. [assertWithSideEffect]
    assert(L.last() == 11);
             ^
data_structures/reverse_a_linked_list.cpp:62:10: style:inconclusive: Technically the member function 'data_structures::linked_list::list::isEmpty' can be const. [functionConst]
    bool isEmpty();
         ^
data_structures/reverse_a_linked_list.cpp:76:12: note: Technically the member function 'data_structures::linked_list::list::isEmpty' can be const.
bool list::isEmpty() { return head == nullptr; }
           ^
data_structures/reverse_a_linked_list.cpp:62:10: note: Technically the member function 'data_structures::linked_list::list::isEmpty' can be const.
    bool isEmpty();
         ^
data_structures/reverse_a_linked_list.cpp:82:27: style:inconclusive: Function 'insert' argument 1 names different: declaration 'new_elem' definition 'n'. [funcArgNamesDifferent]
void list::insert(int32_t n) {
                          ^
data_structures/reverse_a_linked_list.cpp:63:25: note: Function 'insert' argument 1 names different: declaration 'new_elem' definition 'n'.
    void insert(int32_t new_elem);
                        ^
data_structures/reverse_a_linked_list.cpp:82:27: note: Function 'insert' argument 1 names different: declaration 'new_elem' definition 'n'.
void list::insert(int32_t n) {
                          ^
data_structures/skip_list.cpp:67:9: performance: Variable 'header' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        header = std::make_shared<Node>(-1, MAX_LEVEL);
        ^
data_structures/skip_list.cpp:75:9: performance:inconclusive: Technically the member function 'data_structures::SkipList::randomLevel' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    int randomLevel() {
        ^
data_structures/skip_list.cpp:191:10: style:inconclusive: Technically the member function 'data_structures::SkipList::displayList' can be const. [functionConst]
    void displayList() {
         ^
data_structures/sparse_table.cpp:148:15: warning: Assert statement calls a function which may have desired side effects: 'query'. [assertWithSideEffect]
    assert(st.query(1, 9) == 1);  ///< as 1 is smallest from 1..9
              ^
data_structures/sparse_table.cpp:149:15: warning: Assert statement calls a function which may have desired side effects: 'query'. [assertWithSideEffect]
    assert(st.query(2, 6) == 2);  ///< as 2 is smallest from 2..6
              ^
data_structures/sparse_table.cpp:150:15: warning: Assert statement calls a function which may have desired side effects: 'query'. [assertWithSideEffect]
    assert(st.query(3, 8) == 3);  ///< as 3 is smallest from 3..8
              ^
data_structures/sparse_table.cpp:109:13: style:inconclusive: Technically the member function 'data_structures::sparse_table::Sparse_table::query' can be const. [functionConst]
    int64_t query(int64_t l, int64_t r) {
            ^
data_structures/stack_using_queue.cpp:88:14: warning: Assert statement calls a function which may have desired side effects: 'size'. [assertWithSideEffect]
    assert(s.size() == 3);  /// size should be 3
             ^
data_structures/stack_using_queue.cpp:90:14: warning: Assert statement calls a function which may have desired side effects: 'top'. [assertWithSideEffect]
    assert(s.top() == 3);  /// topmost element in the stack should be 3
             ^
data_structures/stack_using_queue.cpp:93:14: warning: Assert statement calls a function which may have desired side effects: 'top'. [assertWithSideEffect]
    assert(s.top() == 2);  /// topmost element in the stack should now be 2
             ^
data_structures/stack_using_queue.cpp:96:14: warning: Assert statement calls a function which may have desired side effects: 'top'. [assertWithSideEffect]
    assert(s.top() == 1);
             ^
data_structures/stack_using_queue.cpp:99:14: warning: Assert statement calls a function which may have desired side effects: 'top'. [assertWithSideEffect]
    assert(s.top() == 5);  /// topmost element in the stack should now be 5
             ^
data_structures/stack_using_queue.cpp:102:14: warning: Assert statement calls a function which may have desired side effects: 'top'. [assertWithSideEffect]
    assert(s.top() == 1);  /// topmost element in the stack should now be 1
             ^
data_structures/stack_using_queue.cpp:104:14: warning: Assert statement calls a function which may have desired side effects: 'size'. [assertWithSideEffect]
    assert(s.size() == 1);  /// size should be 1
             ^
data_structures/stack_using_queue.cpp:73:9: style:inconclusive: Technically the member function 'data_structures::stack_using_queue::Stack::size' can be const. [functionConst]
    int size() { return current_size; }
        ^
data_structures/queue.h:20:10: style:inconclusive: Technically the member function 'queue < std :: string >::display' can be const. [functionConst]
    void display() {
         ^
data_structures/queue.h:42:10: style:inconclusive: Technically the member function 'queue < std :: string >::isEmptyQueue' can be const. [functionConst]
    bool isEmptyQueue() { return (queueFront == NULL); }
         ^
data_structures/queue.h:68:21: style: The scope of the variable 'temp' can be reduced. [variableScope]
        node<Kind> *temp;
                    ^
data_structures/queue.h:45:23: performance: Function parameter 'item' should be passed by const reference. [passedByValue]
    void enQueue(Kind item) {
                      ^
data_structures/stack.h:115:18: warning: 'operator=' should check for assignment to self to avoid problems with dynamic memory. [operatorEqToSelf]
    stack<Type> &operator=(const stack<Type> &otherStack) {
                 ^
data_structures/stack.h:29:10: style:inconclusive: Technically the member function 'stack < int >::display' can be const. [functionConst]
    void display() {
         ^
data_structures/stack.h:80:10: style:inconclusive: Technically the member function 'stack < int >::isEmptyStack' can be const. [functionConst]
    bool isEmptyStack() { return (stackTop == nullptr); }
         ^
data_structures/stack.h:51:22: style: The statement 'if (stackTop!=nullptr) stackTop=nullptr' is logically equivalent to 'stackTop=nullptr'. [duplicateConditionalAssign]
        if (stackTop != nullptr) {
                     ^
data_structures/stack.h:52:22: note: Assignment 'stackTop=nullptr'
            stackTop = nullptr;
                     ^
data_structures/stack.h:51:22: note: Condition 'stackTop!=nullptr' is redundant
        if (stackTop != nullptr) {
                     ^
data_structures/stack.h:119:22: style: The statement 'if (stackTop!=nullptr) stackTop=nullptr' is logically equivalent to 'stackTop=nullptr'. [duplicateConditionalAssign]
        if (stackTop != nullptr) {
                     ^
data_structures/stack.h:120:22: note: Assignment 'stackTop=nullptr'
            stackTop = nullptr;
                     ^
data_structures/stack.h:119:22: note: Condition 'stackTop!=nullptr' is redundant
        if (stackTop != nullptr) {
                     ^
data_structures/stack.h:146:17: style: Class 'stack < int >' is unsafe, 'stack < int >::stackTop' can leak by wrong usage. [unsafeClassCanLeak]
    node<Type> *stackTop; /**< Pointer to the stack */
                ^
data_structures/stack.h:48:41: style: The scope of the variable 'last' can be reduced. [variableScope]
        node<Type> *newNode, *current, *last;
                                        ^
data_structures/stack.h:100:21: style: The scope of the variable 'temp' can be reduced. [variableScope]
        node<Type> *temp;
                    ^
data_structures/stack.h:116:41: style: The scope of the variable 'last' can be reduced. [variableScope]
        node<Type> *newNode, *current, *last;
                                        ^
data_structures/stack.h:29:10: style:inconclusive: Technically the member function 'stack < std :: string >::display' can be const. [functionConst]
    void display() {
         ^
data_structures/stack.h:80:10: style:inconclusive: Technically the member function 'stack < std :: string >::isEmptyStack' can be const. [functionConst]
    bool isEmptyStack() { return (stackTop == nullptr); }
         ^
data_structures/stack.h:146:17: style: Class 'stack < std :: string >' is unsafe, 'stack < std :: string >::stackTop' can leak by wrong usage. [unsafeClassCanLeak]
    node<Type> *stackTop; /**< Pointer to the stack */
                ^
data_structures/stack.h:83:20: performance: Function parameter 'item' should be passed by const reference. [passedByValue]
    void push(Type item) {
                   ^
data_structures/tree.cpp:30:5: error: Memory leak: t [memleak]
    }
    ^
data_structures/tree_234.cpp:252:36: portability: Returning an integer in a function with pointer return type is not portable. [CastIntegerToAddressAtReturn]
    Node *GetChild(int8_t index) { return children[index]; }
                                   ^
data_structures/tree_234.cpp:265:33: portability: Returning an integer in a function with pointer return type is not portable. [CastIntegerToAddressAtReturn]
    Node *GetRightmostChild() { return children[count]; }
                                ^
data_structures/tree_234.cpp:271:32: portability: Returning an integer in a function with pointer return type is not portable. [CastIntegerToAddressAtReturn]
    Node *GetLeftmostChild() { return children[0]; }
                               ^
data_structures/tree_234.cpp:283:9: portability: Returning an integer in a function with pointer return type is not portable. [CastIntegerToAddressAtReturn]
        return children[item_index];
        ^
data_structures/tree_234.cpp:296:9: portability: Returning an integer in a function with pointer return type is not portable. [CastIntegerToAddressAtReturn]
        return children[item_index + 1];
        ^
data_structures/tree_234.cpp:311:9: portability: Returning an integer in a function with pointer return type is not portable. [CastIntegerToAddressAtReturn]
        return children[i];
        ^
data_structures/tree_234.cpp:164:17: warning: Assert statement calls a function which may have desired side effects: 'IsFull'. [assertWithSideEffect]
        assert(!IsFull());
                ^
data_structures/tree_234.cpp:731:43: warning: Assert statement calls a function which may have desired side effects: 'IsFull'. [assertWithSideEffect]
    assert(dst_node && node && !dst_node->IsFull() && node->Is2Node());
                                          ^
data_structures/tree_234.cpp:731:61: warning: Assert statement calls a function which may have desired side effects: 'Is2Node'. [assertWithSideEffect]
    assert(dst_node && node && !dst_node->IsFull() && node->Is2Node());
                                                            ^
data_structures/tree_234.cpp:746:18: warning: Assert statement calls a function which may have desired side effects: 'GetCount'. [assertWithSideEffect]
    assert(node->GetCount() == 3);
                 ^
data_structures/tree_234.cpp:849:26: warning: Assert statement calls a function which may have desired side effects: 'Is34Node'. [assertWithSideEffect]
    assert(left && left->Is34Node());
                         ^
data_structures/tree_234.cpp:850:28: warning: Assert statement calls a function which may have desired side effects: 'Is2Node'. [assertWithSideEffect]
    assert(right && right->Is2Node());
                           ^
data_structures/tree_234.cpp:873:28: warning: Assert statement calls a function which may have desired side effects: 'Is34Node'. [assertWithSideEffect]
    assert(right && right->Is34Node());
                           ^
data_structures/tree_234.cpp:874:26: warning: Assert statement calls a function which may have desired side effects: 'Is2Node'. [assertWithSideEffect]
    assert(left && left->Is2Node());
                         ^
data_structures/tree_234.cpp:903:24: warning: Assert statement calls a function which may have desired side effects: 'Is2Node'. [assertWithSideEffect]
    assert(left_child->Is2Node() && right_child->Is2Node());
                       ^
data_structures/tree_234.cpp:1173:36: warning: Assert statement calls a function which may have desired side effects: 'GetCount'. [assertWithSideEffect]
            assert(node_info.node->GetCount() > 0);
                                   ^
data_structures/tree_234.cpp:315:28: style:inconclusive: Member variable 'Node::items' is in the wrong place in the initializer list. [initializerList]
    std::array<int64_t, 3> items;  ///< store items
                           ^
data_structures/tree_234.cpp:43:11: note: Member variable 'Node::items' is in the wrong place in the initializer list.
          items({{item, 0, 0}}),
          ^
data_structures/tree_234.cpp:315:28: note: Member variable 'Node::items' is in the wrong place in the initializer list.
    std::array<int64_t, 3> items;  ///< store items
                           ^
data_structures/tree_234.cpp:50:12: style:inconclusive: Technically the member function 'data_structures::tree_234::Node::GetCount' can be const. [functionConst]
    int8_t GetCount() { return count; }
           ^
data_structures/tree_234.cpp:67:10: style:inconclusive: Technically the member function 'data_structures::tree_234::Node::IsLeaf' can be const. [functionConst]
    bool IsLeaf() { return children[0] == nullptr; }
         ^
data_structures/tree_234.cpp:73:10: style:inconclusive: Technically the member function 'data_structures::tree_234::Node::IsFull' can be const. [functionConst]
    bool IsFull() { return count == 3; }
         ^
data_structures/tree_234.cpp:79:10: style:inconclusive: Technically the member function 'data_structures::tree_234::Node::Is2Node' can be const. [functionConst]
    bool Is2Node() { return count == 1; }
         ^
data_structures/tree_234.cpp:85:10: style:inconclusive: Technically the member function 'data_structures::tree_234::Node::Is34Node' can be const. [functionConst]
    bool Is34Node() { return count == 2 || count == 3; }
         ^
data_structures/tree_234.cpp:92:10: style:inconclusive: Technically the member function 'data_structures::tree_234::Node::Contains' can be const. [functionConst]
    bool Contains(int64_t item) {
         ^
data_structures/tree_234.cpp:107:12: style:inconclusive: Technically the member function 'data_structures::tree_234::Node::GetItemIndex' can be const. [functionConst]
    int8_t GetItemIndex(int64_t item) {
           ^
data_structures/tree_234.cpp:120:13: style:inconclusive: Technically the member function 'data_structures::tree_234::Node::GetMaxItem' can be const. [functionConst]
    int64_t GetMaxItem() { return items[count - 1]; }
            ^
data_structures/tree_234.cpp:126:13: style:inconclusive: Technically the member function 'data_structures::tree_234::Node::GetMinItem' can be const. [functionConst]
    int64_t GetMinItem() { return items[0]; }
            ^
data_structures/tree_234.cpp:133:13: style:inconclusive: Technically the member function 'data_structures::tree_234::Node::GetItem' can be const. [functionConst]
    int64_t GetItem(int8_t index) { return items[index]; }
            ^
data_structures/tree_234.cpp:237:12: style:inconclusive: Technically the member function 'data_structures::tree_234::Node::GetChildIndex' can be const. [functionConst]
    int8_t GetChildIndex(Node *child) {
           ^
data_structures/tree_234.cpp:402:10: performance:inconclusive: Technically the member function 'data_structures::tree_234::Tree234::MergeNodeNotFull' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void MergeNodeNotFull(Node *dst_node, Node *node);
         ^
data_structures/tree_234.cpp:730:15: note: Technically the member function 'data_structures::tree_234::Tree234::MergeNodeNotFull' can be static (but you may consider moving to unnamed namespace).
void Tree234::MergeNodeNotFull(Node *dst_node, Node *node) {
              ^
data_structures/tree_234.cpp:402:10: note: Technically the member function 'data_structures::tree_234::Tree234::MergeNodeNotFull' can be static (but you may consider moving to unnamed namespace).
    void MergeNodeNotFull(Node *dst_node, Node *node);
         ^
data_structures/tree_234.cpp:417:13: performance:inconclusive: Technically the member function 'data_structures::tree_234::Tree234::GetTreeMaxItem' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    int64_t GetTreeMaxItem(Node *tree);
            ^
data_structures/tree_234.cpp:1098:18: note: Technically the member function 'data_structures::tree_234::Tree234::GetTreeMaxItem' can be static (but you may consider moving to unnamed namespace).
int64_t Tree234::GetTreeMaxItem(Node *tree) {
                 ^
data_structures/tree_234.cpp:417:13: note: Technically the member function 'data_structures::tree_234::Tree234::GetTreeMaxItem' can be static (but you may consider moving to unnamed namespace).
    int64_t GetTreeMaxItem(Node *tree);
            ^
data_structures/tree_234.cpp:424:13: performance:inconclusive: Technically the member function 'data_structures::tree_234::Tree234::GetTreeMinItem' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    int64_t GetTreeMinItem(Node *tree);
            ^
data_structures/tree_234.cpp:1115:18: note: Technically the member function 'data_structures::tree_234::Tree234::GetTreeMinItem' can be static (but you may consider moving to unnamed namespace).
int64_t Tree234::GetTreeMinItem(Node *tree) {
                 ^
data_structures/tree_234.cpp:424:13: note: Technically the member function 'data_structures::tree_234::Tree234::GetTreeMinItem' can be static (but you may consider moving to unnamed namespace).
    int64_t GetTreeMinItem(Node *tree);
            ^
data_structures/tree_234.cpp:472:10: performance:inconclusive: Technically the member function 'data_structures::tree_234::Tree234::RightRotate' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void RightRotate(Node *parent, int8_t index);
         ^
data_structures/tree_234.cpp:845:15: note: Technically the member function 'data_structures::tree_234::Tree234::RightRotate' can be static (but you may consider moving to unnamed namespace).
void Tree234::RightRotate(Node *parent, int8_t index) {
              ^
data_structures/tree_234.cpp:472:10: note: Technically the member function 'data_structures::tree_234::Tree234::RightRotate' can be static (but you may consider moving to unnamed namespace).
    void RightRotate(Node *parent, int8_t index);
         ^
data_structures/tree_234.cpp:485:10: performance:inconclusive: Technically the member function 'data_structures::tree_234::Tree234::LeftRotate' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void LeftRotate(Node *parent, int8_t index);
         ^
data_structures/tree_234.cpp:869:15: note: Technically the member function 'data_structures::tree_234::Tree234::LeftRotate' can be static (but you may consider moving to unnamed namespace).
void Tree234::LeftRotate(Node *parent, int8_t index) {
              ^
data_structures/tree_234.cpp:485:10: note: Technically the member function 'data_structures::tree_234::Tree234::LeftRotate' can be static (but you may consider moving to unnamed namespace).
    void LeftRotate(Node *parent, int8_t index);
         ^
data_structures/tree_234.cpp:535:10: performance:inconclusive: Technically the member function 'data_structures::tree_234::Tree234::PrintNode' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void PrintNode(std::ofstream &ofs, Node *node, int64_t parent_index,
         ^
data_structures/tree_234.cpp:1226:15: note: Technically the member function 'data_structures::tree_234::Tree234::PrintNode' can be static (but you may consider moving to unnamed namespace).
void Tree234::PrintNode(std::ofstream &ofs, Node *node, int64_t parent_index,
              ^
data_structures/tree_234.cpp:535:10: note: Technically the member function 'data_structures::tree_234::Tree234::PrintNode' can be static (but you may consider moving to unnamed namespace).
    void PrintNode(std::ofstream &ofs, Node *node, int64_t parent_index,
         ^
data_structures/tree_234.cpp:1147:13: style: The scope of the variable 'index' can be reduced. [variableScope]
    int64_t index = 0;
            ^
data_structures/tree_234.cpp:567:30: style:inconclusive: Function 'Traverse' argument 1 names different: declaration 'tree' definition 'node'. [funcArgNamesDifferent]
void Tree234::Traverse(Node *node) {
                             ^
data_structures/tree_234.cpp:520:25: note: Function 'Traverse' argument 1 names different: declaration 'tree' definition 'node'.
    void Traverse(Node *tree);
                        ^
data_structures/tree_234.cpp:567:30: note: Function 'Traverse' argument 1 names different: declaration 'tree' definition 'node'.
void Tree234::Traverse(Node *node) {
                             ^
data_structures/trie_modern.cpp:132:10: style:inconclusive: Technically the member function 'Trie::search' can be const. [functionConst]
    bool search(const std::string& word) {
         ^
data_structures/trie_tree.cpp:183:18: warning: Assert statement calls a function which may have desired side effects: 'search'. [assertWithSideEffect]
    assert(!root.search("hello", 0));
                 ^
data_structures/trie_tree.cpp:186:17: warning: Assert statement calls a function which may have desired side effects: 'search'. [assertWithSideEffect]
    assert(root.search("Hello", 0));
                ^
data_structures/trie_tree.cpp:189:18: warning: Assert statement calls a function which may have desired side effects: 'search'. [assertWithSideEffect]
    assert(!root.search("Word", 0));
                 ^
data_structures/trie_tree.cpp:192:17: warning: Assert statement calls a function which may have desired side effects: 'search'. [assertWithSideEffect]
    assert(root.search("World", 0));
                ^
data_structures/trie_tree.cpp:38:13: performance:inconclusive: Technically the member function 'data_structures::trie::char_to_int' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    uint8_t char_to_int(const char& ch) const {
            ^
data_structures/trie_using_hashmap.cpp:238:17: warning: Assert statement calls a function which may have desired side effects: 'search'. [assertWithSideEffect]
    assert(!obj.search("appy"));
                ^
data_structures/trie_using_hashmap.cpp:241:17: warning: Assert statement calls a function which may have desired side effects: 'search'. [assertWithSideEffect]
    assert(!obj.search("car"));
                ^
data_structures/trie_using_hashmap.cpp:243:16: warning: Assert statement calls a function which may have desired side effects: 'search'. [assertWithSideEffect]
    assert(obj.search("app"));
               ^
data_structures/trie_using_hashmap.cpp:244:16: warning: Assert statement calls a function which may have desired side effects: 'search'. [assertWithSideEffect]
    assert(obj.search("apple"));
               ^
data_structures/trie_using_hashmap.cpp:245:16: warning: Assert statement calls a function which may have desired side effects: 'search'. [assertWithSideEffect]
    assert(obj.search("apples"));
               ^
data_structures/trie_using_hashmap.cpp:246:16: warning: Assert statement calls a function which may have desired side effects: 'search'. [assertWithSideEffect]
    assert(obj.search("apps"));
               ^
data_structures/trie_using_hashmap.cpp:247:16: warning: Assert statement calls a function which may have desired side effects: 'search'. [assertWithSideEffect]
    assert(obj.search("apen"));
               ^
data_structures/trie_using_hashmap.cpp:248:16: warning: Assert statement calls a function which may have desired side effects: 'search'. [assertWithSideEffect]
    assert(obj.search("approach"));
               ^
data_structures/trie_using_hashmap.cpp:249:16: warning: Assert statement calls a function which may have desired side effects: 'search'. [assertWithSideEffect]
    assert(obj.search("about"));
               ^
data_structures/trie_using_hashmap.cpp:250:16: warning: Assert statement calls a function which may have desired side effects: 'search'. [assertWithSideEffect]
    assert(obj.search("abscond"));
               ^
data_structures/trie_using_hashmap.cpp:251:16: warning: Assert statement calls a function which may have desired side effects: 'search'. [assertWithSideEffect]
    assert(obj.search("bus"));
               ^
data_structures/trie_using_hashmap.cpp:252:16: warning: Assert statement calls a function which may have desired side effects: 'search'. [assertWithSideEffect]
    assert(obj.search("buses"));
               ^
data_structures/trie_using_hashmap.cpp:253:16: warning: Assert statement calls a function which may have desired side effects: 'search'. [assertWithSideEffect]
    assert(obj.search("Bounce"));
               ^
data_structures/trie_using_hashmap.cpp:254:16: warning: Assert statement calls a function which may have desired side effects: 'search'. [assertWithSideEffect]
    assert(obj.search("Apple"));
               ^
data_structures/trie_using_hashmap.cpp:259:17: warning: Assert statement calls a function which may have desired side effects: 'startwith'. [assertWithSideEffect]
    assert(!obj.startwith("approachs"));
                ^
data_structures/trie_using_hashmap.cpp:260:16: warning: Assert statement calls a function which may have desired side effects: 'startwith'. [assertWithSideEffect]
    assert(obj.startwith("approach"));
               ^
data_structures/trie_using_hashmap.cpp:261:16: warning: Assert statement calls a function which may have desired side effects: 'startwith'. [assertWithSideEffect]
    assert(obj.startwith("about"));
               ^
data_structures/trie_using_hashmap.cpp:262:17: warning: Assert statement calls a function which may have desired side effects: 'startwith'. [assertWithSideEffect]
    assert(!obj.startwith("appy"));
                ^
data_structures/trie_using_hashmap.cpp:263:16: warning: Assert statement calls a function which may have desired side effects: 'startwith'. [assertWithSideEffect]
    assert(obj.startwith("abscond"));
               ^
data_structures/trie_using_hashmap.cpp:264:16: warning: Assert statement calls a function which may have desired side effects: 'startwith'. [assertWithSideEffect]
    assert(obj.startwith("bus"));
               ^
data_structures/trie_using_hashmap.cpp:265:16: warning: Assert statement calls a function which may have desired side effects: 'startwith'. [assertWithSideEffect]
    assert(obj.startwith("buses"));
               ^
data_structures/trie_using_hashmap.cpp:266:16: warning: Assert statement calls a function which may have desired side effects: 'startwith'. [assertWithSideEffect]
    assert(obj.startwith("Bounce"));
               ^
data_structures/trie_using_hashmap.cpp:267:16: warning: Assert statement calls a function which may have desired side effects: 'startwith'. [assertWithSideEffect]
    assert(obj.startwith("Apple"));
               ^
data_structures/trie_using_hashmap.cpp:268:16: warning: Assert statement calls a function which may have desired side effects: 'startwith'. [assertWithSideEffect]
    assert(obj.startwith("abs"));
               ^
data_structures/trie_using_hashmap.cpp:269:16: warning: Assert statement calls a function which may have desired side effects: 'startwith'. [assertWithSideEffect]
    assert(obj.startwith("b"));
               ^
data_structures/trie_using_hashmap.cpp:270:16: warning: Assert statement calls a function which may have desired side effects: 'startwith'. [assertWithSideEffect]
    assert(obj.startwith("bus"));
               ^
data_structures/trie_using_hashmap.cpp:271:16: warning: Assert statement calls a function which may have desired side effects: 'startwith'. [assertWithSideEffect]
    assert(obj.startwith("Bo"));
               ^
data_structures/trie_using_hashmap.cpp:272:16: warning: Assert statement calls a function which may have desired side effects: 'startwith'. [assertWithSideEffect]
    assert(obj.startwith("A"));
               ^
data_structures/trie_using_hashmap.cpp:273:17: warning: Assert statement calls a function which may have desired side effects: 'startwith'. [assertWithSideEffect]
    assert(!obj.startwith("Ca"));
                ^
data_structures/trie_using_hashmap.cpp:275:17: warning: Assert statement calls a function which may have desired side effects: 'startwith'. [assertWithSideEffect]
    assert(!obj.startwith("C"));
                ^
data_structures/trie_using_hashmap.cpp:316:17: warning: Assert statement calls a function which may have desired side effects: 'search'. [assertWithSideEffect]
    assert(!obj.search("app"));
                ^
data_structures/trie_using_hashmap.cpp:329:16: warning: Assert statement calls a function which may have desired side effects: 'startwith'. [assertWithSideEffect]
    assert(obj.startwith("苹"));
               ^
data_structures/trie_using_hashmap.cpp:82:10: style:inconclusive: Technically the member function 'data_structures::trie_using_hashmap::Trie::search' can be const. [functionConst]
    bool search(const std::string& word) {
         ^
data_structures/trie_using_hashmap.cpp:107:10: style:inconclusive: Technically the member function 'data_structures::trie_using_hashmap::Trie::startwith' can be const. [functionConst]
    bool startwith(const std::string& prefix) {
         ^
data_structures/trie_using_hashmap.cpp:122:10: style:inconclusive: Technically the member function 'data_structures::trie_using_hashmap::Trie::delete_word' can be const. [functionConst]
    void delete_word(std::string word) {
         ^
dynamic_programming/armstrong_number.cpp:8:26: style: The scope of the variable 'rem' can be reduced. [variableScope]
    int n = 0, temp = 0, rem = 0, count = 0, sum = 0;
                         ^
dynamic_programming/armstrong_number.cpp:8:30: style: Variable 'rem' is assigned a value that is never used. [unreadVariable]
    int n = 0, temp = 0, rem = 0, count = 0, sum = 0;
                             ^
dynamic_programming/bellman_ford.cpp:16:11: style: Class 'Graph' is unsafe, 'Graph::edges' can leak by wrong usage. [unsafeClassCanLeak]
    Edge *edges;
          ^
dynamic_programming/bellman_ford.cpp:22:23: style: C-style pointer casting [cstyleCast]
        this->edges = (Edge *)malloc(E * sizeof(Edge));
                      ^
dynamic_programming/floyd_warshall.cpp:18:15: warning: Class 'Graph' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
        this->edges = new int *[V];
              ^
dynamic_programming/floyd_warshall.cpp:18:15: warning: Class 'Graph' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
        this->edges = new int *[V];
              ^
dynamic_programming/floyd_warshall.cpp:16:5: style: Class 'Graph' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    Graph(int V) {
    ^
dynamic_programming/longest_common_string.cpp:36:15: style: The scope of the variable 'indj' can be reduced. [variableScope]
    int indi, indj;
              ^
dynamic_programming/longest_common_string.cpp:42:22: style: Variable 'indj' is assigned a value that is never used. [unreadVariable]
                indj = j;
                     ^
dynamic_programming/longest_common_string.cpp:9:15: style: Unused variable: k [unusedVariable]
    int i, j, k;
              ^
dynamic_programming/shortest_common_supersequence.cpp:155:13: style: Local variable 'i' shadows outer variable [shadowVariable]
    for(int i=0; i < scsStrings.size(); i++) {
            ^
dynamic_programming/shortest_common_supersequence.cpp:135:9: note: Shadowed declaration
    int i=0;
        ^
dynamic_programming/shortest_common_supersequence.cpp:155:13: note: Shadow variable
    for(int i=0; i < scsStrings.size(); i++) {
            ^
dynamic_programming/word_break.cpp:135:22: style: Local variable 's' shadows outer argument [shadowArgument]
    for (const auto &s : wordDict) {
                     ^
dynamic_programming/word_break.cpp:131:35: note: Shadowed declaration
bool wordBreak(const std::string &s, const std::vector<std::string> &wordDict) {
                                  ^
dynamic_programming/word_break.cpp:135:22: note: Shadow variable
    for (const auto &s : wordDict) {
                     ^
geometry/graham_scan_algorithm.cpp:57:46: style: Unused variable: res [unusedVariable]
    std::vector<geometry::grahamscan::Point> res;
                                             ^
geometry/jarvis_algorithm.cpp:67:17: performance: Variable 'points' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
                points = pointList;
                ^
geometry/jarvis_algorithm.cpp:92:41: style: The scope of the variable 'q' can be reduced. [variableScope]
                int p = leftmost_point, q = 0;
                                        ^
geometry/jarvis_algorithm.cpp:92:43: style: Variable 'q' is assigned a value that is never used. [unreadVariable]
                int p = leftmost_point, q = 0;
                                          ^
geometry/line_segment_intersection.cpp:63:16: performance:inconclusive: Technically the member function 'SegmentIntersection::direction' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    inline int direction(Point first_point, Point second_point,
               ^
geometry/line_segment_intersection.cpp:75:17: performance:inconclusive: Technically the member function 'SegmentIntersection::on_segment' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    inline bool on_segment(Point first_point, Point second_point,
                ^
graph/bidirectional_dijkstra.cpp:212:74: style: Same expression on both sides of '-'. [duplicateExpression]
    assert(graph::bidirectional_dijkstra::Bidijkstra(&adj1_1, &adj1_2, s - 1,
                                                                         ^
graph/bidirectional_dijkstra.cpp:211:18: note: 's' is assigned value '1' here.
    uint64_t s = 1, t = 3;
                 ^
graph/bidirectional_dijkstra.cpp:212:74: note: Same expression on both sides of '-'.
    assert(graph::bidirectional_dijkstra::Bidijkstra(&adj1_1, &adj1_2, s - 1,
                                                                         ^
graph/bidirectional_dijkstra.cpp:67:22: style: Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]
            distance = distance_[0][i] + distance_[1][i];
                     ^
graph/dijkstra.cpp:124:37: style: Same expression on both sides of '-'. [duplicateExpression]
    assert(graph::dijkstra(&adj1, s - 1, t - 1) == 3);
                                    ^
graph/dijkstra.cpp:123:13: note: 's' is assigned value '1' here.
    int s = 1, t = 3;
            ^
graph/dijkstra.cpp:124:37: note: Same expression on both sides of '-'.
    assert(graph::dijkstra(&adj1, s - 1, t - 1) == 3);
                                    ^
graph/hopcroft_karp.cpp:234:5: performance: Variable 'adj' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
    adj = std::vector<std::list<int> >(m + 1);
    ^
graph/hopcroft_karp.cpp:257:32: style: Variable 'e1' is assigned a value that is never used. [unreadVariable]
      int v1a = 3, v1b = 5, e1 = 2;  // vertices of left side, right side and edges
                               ^
graph/hopcroft_karp.cpp:269:37: style: Variable 'e2' is assigned a value that is never used. [unreadVariable]
           int v2a = 4, v2b = 4, e2 = 6;  // vertices of left side, right side and edges
                                    ^
graph/hopcroft_karp.cpp:285:37: style: Variable 'e3' is assigned a value that is never used. [unreadVariable]
           int v3a = 6, v3b = 6, e3 = 4;  // vertices of left side, right side and edges
                                    ^
graph/max_flow_with_ford_fulkerson_and_edmond_karp_algo.cpp:31:52: style: The comparison 'is_path_found == false' is always true because 'is_path_found' and 'false' represent the same value. [knownConditionTrueFalse]
        while (q.empty() == false && is_path_found == false) {
                                                   ^
graph/max_flow_with_ford_fulkerson_and_edmond_karp_algo.cpp:30:30: note: 'is_path_found' is assigned value 'false' here.
        bool is_path_found = false;
                             ^
graph/max_flow_with_ford_fulkerson_and_edmond_karp_algo.cpp:31:52: note: The comparison 'is_path_found == false' is always true because 'is_path_found' and 'false' represent the same value.
        while (q.empty() == false && is_path_found == false) {
                                                   ^
graph/max_flow_with_ford_fulkerson_and_edmond_karp_algo.cpp:96:17: style: Local variable 'source' shadows outer variable [shadowVariable]
            int source = 0, destination = 0, capacity_ = 0;
                ^
graph/max_flow_with_ford_fulkerson_and_edmond_karp_algo.cpp:21:26: note: Shadowed declaration
    int total_edges = 0, source = 0, sink = 0;
                         ^
graph/max_flow_with_ford_fulkerson_and_edmond_karp_algo.cpp:96:17: note: Shadow variable
            int source = 0, destination = 0, capacity_ = 0;
                ^
graph/topological_sort_by_kahns_algo.cpp:35:35: style:inconclusive: Function 'topoSortKahn' argument 1 names different: declaration 'N' definition 'V'. [funcArgNamesDifferent]
std::vector<int> topoSortKahn(int V,
                                  ^
graph/topological_sort_by_kahns_algo.cpp:7:35: note: Function 'topoSortKahn' argument 1 names different: declaration 'N' definition 'V'.
std::vector<int> topoSortKahn(int N, const std::vector<std::vector<int> > &adj);
                                  ^
graph/topological_sort_by_kahns_algo.cpp:35:35: note: Function 'topoSortKahn' argument 1 names different: declaration 'N' definition 'V'.
std::vector<int> topoSortKahn(int V,
                                  ^
graphics/spirograph.cpp:75:13: style: Local variable 'step' shadows outer variable [shadowVariable]
    int32_t step = 0;
            ^
graphics/spirograph.cpp:123:21: note: Shadowed declaration
static const double step = 0.01;   /**< animation step size */
                    ^
graphics/spirograph.cpp:75:13: note: Shadow variable
    int32_t step = 0;
            ^
greedy_algorithms/dijkstra.cpp:15:15: warning: Class 'Graph' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
        this->edges = new int *[V];
              ^
greedy_algorithms/dijkstra.cpp:15:15: warning: Class 'Graph' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
        this->edges = new int *[V];
              ^
greedy_algorithms/dijkstra.cpp:15:15: warning: Class 'Graph' does not have a destructor which is recommended since it has dynamic memory/resource allocation(s). [noDestructor]
        this->edges = new int *[V];
              ^
greedy_algorithms/dijkstra.cpp:13:5: style: Class 'Graph' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    Graph(const int V) {
    ^
greedy_algorithms/dijkstra.cpp:10:11: style: Class 'Graph' is unsafe, 'Graph::edges' can leak by wrong usage. [unsafeClassCanLeak]
    int **edges;
          ^
greedy_algorithms/huffman.cpp:29:10: style:inconclusive: Technically the member function 'compare::operator()' can be const. [functionConst]
    bool operator()(MinHeapNode* l, MinHeapNode* r)
         ^
greedy_algorithms/huffman.cpp:52:40: style: The scope of the variable 'top' can be reduced. [variableScope]
    struct MinHeapNode *left, *right, *top;
                                       ^
greedy_algorithms/huffman.cpp:38:50: performance: Function parameter 'str' should be passed by const reference. [passedByValue]
void printCodes(struct MinHeapNode* root, string str) {
                                                 ^
greedy_algorithms/jumpgame.cpp:28:38: style: Unsigned expression 'i' can't be negative so it is unnecessary to test it. [unsignedPositive]
    for (auto i = nums.size() - 1; i >= 0; i--) {
                                     ^
greedy_algorithms/knapsack.cpp:70:22: style: Variable 'capacity' is assigned a value that is never used. [unreadVariable]
            capacity = 0;
                     ^
hashing/chaining.cpp:63:10: style:inconclusive: Technically the member function 'hash_chain::display' can be const. [functionConst]
    void display() {
         ^
hashing/chaining.cpp:52:18: style: Variable 'curr' is assigned a value that is never used. [unreadVariable]
            curr = head[h];
                 ^
hashing/md5.cpp:175:31: style: The scope of the variable 'A' can be reduced. [variableScope]
    uint32_t a0 = 0x67452301, A = 0;
                              ^
hashing/md5.cpp:78:18: style: union member 'Anonymous0::i' is never used. [unusedStructMember]
        uint32_t i;
                 ^
hashing/sha1.cpp:87:31: style: The scope of the variable 'a' can be reduced. [variableScope]
    uint32_t h0 = 0x67452301, a = 0;
                              ^
hashing/sha1.cpp:88:31: style: The scope of the variable 'b' can be reduced. [variableScope]
    uint32_t h1 = 0xEFCDAB89, b = 0;
                              ^
hashing/sha1.cpp:91:31: style: The scope of the variable 'e' can be reduced. [variableScope]
    uint32_t h4 = 0xC3D2E1F0, e = 0;
                              ^
machine_learning/a_star_search.cpp:139:5: warning:inconclusive: Member variable 'EightPuzzle < 3 >::moves' is not assigned in the copy constructor. Should it be copied? [uninitMemberVar]
    EightPuzzle(const EightPuzzle<N> &A) : board(A.board) {}
    ^
machine_learning/a_star_search.cpp:145:5: warning:inconclusive: Member variable 'EightPuzzle < 3 >::moves' is not assigned in the copy constructor. Should it be copied? [uninitMemberVar]
    EightPuzzle(const EightPuzzle<N> &&A) noexcept
    ^
machine_learning/a_star_search.cpp:156:18: warning:inconclusive: Member variable 'EightPuzzle < 3 >::moves' is not assigned a value in 'EightPuzzle < 3 >::operator='. [operatorEqVarError]
    EightPuzzle &operator=(const EightPuzzle &A) {
                 ^
machine_learning/a_star_search.cpp:139:5: warning:inconclusive: Member variable 'EightPuzzle < 4 >::moves' is not assigned in the copy constructor. Should it be copied? [uninitMemberVar]
    EightPuzzle(const EightPuzzle<N> &A) : board(A.board) {}
    ^
machine_learning/a_star_search.cpp:145:5: warning:inconclusive: Member variable 'EightPuzzle < 4 >::moves' is not assigned in the copy constructor. Should it be copied? [uninitMemberVar]
    EightPuzzle(const EightPuzzle<N> &&A) noexcept
    ^
machine_learning/a_star_search.cpp:156:18: warning:inconclusive: Member variable 'EightPuzzle < 4 >::moves' is not assigned a value in 'EightPuzzle < 4 >::operator='. [operatorEqVarError]
    EightPuzzle &operator=(const EightPuzzle &A) {
                 ^
machine_learning/a_star_search.cpp:393:9: performance: Variable 'Initial' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        Initial = std::make_shared<Info>(initial);
        ^
machine_learning/a_star_search.cpp:394:9: performance: Variable 'Final' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        Final = std::make_shared<Info>(final);
        ^
machine_learning/a_star_search.cpp:405:25: performance:inconclusive: Technically the member function 'AyStarSearch < machine_learning :: aystar_search :: EightPuzzle < 3 > >::Solution' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    std::vector<Puzzle> Solution(
                        ^
machine_learning/a_star_search.cpp:405:25: performance:inconclusive: Technically the member function 'AyStarSearch < machine_learning :: aystar_search :: EightPuzzle < 4 > >::Solution' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    std::vector<Puzzle> Solution(
                        ^
machine_learning/a_star_search.cpp:75:35: style:inconclusive: Technically the member function 'EightPuzzle < 3 >::find_zero' can be const. [functionConst]
    std::pair<uint32_t, uint32_t> find_zero() {
                                  ^
machine_learning/a_star_search.cpp:90:17: performance:inconclusive: Technically the member function 'EightPuzzle < 3 >::in_range' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    inline bool in_range(const uint32_t value) const { return value < N; }
                ^
machine_learning/a_star_search.cpp:111:44: style:inconclusive: Technically the member function 'EightPuzzle < 3 >::get_state' can be const. [functionConst]
    std::array<std::array<uint32_t, N>, N> get_state() { return board; }
                                           ^
machine_learning/a_star_search.cpp:117:19: performance:inconclusive: Technically the member function 'EightPuzzle < 3 >::get_size' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    inline size_t get_size() const { return N; }
                  ^
machine_learning/a_star_search.cpp:75:35: style:inconclusive: Technically the member function 'EightPuzzle < 4 >::find_zero' can be const. [functionConst]
    std::pair<uint32_t, uint32_t> find_zero() {
                                  ^
machine_learning/a_star_search.cpp:90:17: performance:inconclusive: Technically the member function 'EightPuzzle < 4 >::in_range' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    inline bool in_range(const uint32_t value) const { return value < N; }
                ^
machine_learning/a_star_search.cpp:111:44: style:inconclusive: Technically the member function 'EightPuzzle < 4 >::get_state' can be const. [functionConst]
    std::array<std::array<uint32_t, N>, N> get_state() { return board; }
                                           ^
machine_learning/a_star_search.cpp:117:19: performance:inconclusive: Technically the member function 'EightPuzzle < 4 >::get_size' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    inline size_t get_size() const { return N; }
                  ^
machine_learning/a_star_search.cpp:561:28: style:inconclusive: Same expression used in consecutive assignments of 'm' and 'n'. [duplicateAssignExpression]
                    size_t m = first.get_size(), n = first.get_size();
                           ^
machine_learning/a_star_search.cpp:561:50: note: Same expression used in consecutive assignments of 'm' and 'n'.
                    size_t m = first.get_size(), n = first.get_size();
                                                 ^
machine_learning/a_star_search.cpp:561:28: note: Same expression used in consecutive assignments of 'm' and 'n'.
                    size_t m = first.get_size(), n = first.get_size();
                           ^
machine_learning/a_star_search.cpp:670:28: style:inconclusive: Same expression used in consecutive assignments of 'm' and 'n'. [duplicateAssignExpression]
                    size_t m = first.get_size(), n = first.get_size();
                           ^
machine_learning/a_star_search.cpp:670:50: note: Same expression used in consecutive assignments of 'm' and 'n'.
                    size_t m = first.get_size(), n = first.get_size();
                                                 ^
machine_learning/a_star_search.cpp:670:28: note: Same expression used in consecutive assignments of 'm' and 'n'.
                    size_t m = first.get_size(), n = first.get_size();
                           ^
machine_learning/adaline_learning.cpp:186:9: performance:inconclusive: Technically the member function 'machine_learning::adaline::activation' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    int activation(double x) { return x > 0 ? 1 : -1; }
        ^
machine_learning/adaline_learning.cpp:196:10: style:inconclusive: Technically the member function 'machine_learning::adaline::check_size_match' can be const. [functionConst]
    bool check_size_match(const std::vector<double> &x) {
         ^
machine_learning/adaline_learning.cpp:69:47: style: Consider using std::fill algorithm instead of a raw loop. [useStlAlgorithm]
        for (double &weight : weights) weight = 1.f;
                                              ^
machine_learning/kohonen_som_topology.cpp:204:18: style: Variable 'y' is assigned a value that is never used. [unreadVariable]
    int x = 0, y = 0;
                 ^
machine_learning/kohonen_som_topology.cpp:370:11: style: Variable 'j' is assigned a value that is never used. [unreadVariable]
    int j = 0, N = 300;
          ^
machine_learning/kohonen_som_topology.cpp:452:11: style: Variable 'j' is assigned a value that is never used. [unreadVariable]
    int j = 0, N = 300;
          ^
machine_learning/kohonen_som_topology.cpp:538:11: style: Variable 'j' is assigned a value that is never used. [unreadVariable]
    int j = 0, N = 500;
          ^
machine_learning/kohonen_som_trace.cpp:106:18: style: Variable 'k' is assigned a value that is never used. [unreadVariable]
    int j = 0, k = 0;
                 ^
machine_learning/kohonen_som_trace.cpp:234:11: style: Variable 'j' is assigned a value that is never used. [unreadVariable]
    int j = 0, N = 500;
          ^
machine_learning/kohonen_som_trace.cpp:316:11: style: Variable 'j' is assigned a value that is never used. [unreadVariable]
    int j = 0, N = 500;
          ^
machine_learning/kohonen_som_trace.cpp:415:11: style: Variable 'j' is assigned a value that is never used. [unreadVariable]
    int j = 0, N = 200;
          ^
machine_learning/neural_network.cpp:821:21: warning: Assert statement calls a function which may have desired side effects: 'single_predict'. [assertWithSideEffect]
               myNN.single_predict({{5, 3.4, 1.6, 0.4}})) == 0);
                    ^
machine_learning/neural_network.cpp:823:21: warning: Assert statement calls a function which may have desired side effects: 'single_predict'. [assertWithSideEffect]
               myNN.single_predict({{6.4, 2.9, 4.3, 1.3}})) == 1);
                    ^
machine_learning/neural_network.cpp:825:21: warning: Assert statement calls a function which may have desired side effects: 'single_predict'. [assertWithSideEffect]
               myNN.single_predict({{6.2, 3.4, 5.4, 2.3}})) == 2);
                    ^
machine_learning/neural_network.cpp:289:5: style:inconclusive: Technically the member function 'machine_learning::neural_network::NeuralNetwork::__detailed_single_prediction' can be const. [functionConst]
    __detailed_single_prediction(const std::vector<std::valarray<double>> &X) {
    ^
machine_learning/neural_network.cpp:652:10: style:inconclusive: Technically the member function 'machine_learning::neural_network::NeuralNetwork::save_model' can be const. [functionConst]
    void save_model(const std::string &_file_name) {
         ^
machine_learning/neural_network.cpp:519:33: style: Local variable 'i' shadows outer variable [shadowVariable]
                    for (size_t i = 0; i < gradients.size(); i++) {
                                ^
machine_learning/neural_network.cpp:509:29: note: Shadowed declaration
                for (size_t i = batch_start;
                            ^
machine_learning/neural_network.cpp:519:33: note: Shadow variable
                    for (size_t i = 0; i < gradients.size(); i++) {
                                ^
machine_learning/vector_ops.hpp:179:15: style: Consider using std::fill or std::generate algorithm instead of a raw loop. [useStlAlgorithm]
            r = distribution(generator);  // copy random number
              ^
machine_learning/vector_ops.hpp:235:17: style: Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]
        cur_sum += a.sum();    // Add sum of that row to current sum
                ^
machine_learning/vector_ops.hpp:352:11: style: Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]
        b = b * val;     // Multiply row with scaler
          ^
machine_learning/vector_ops.hpp:370:11: style: Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]
        b = b / val;     // Divide row with scaler
          ^
machine_learning/ordinary_least_squares_regressor.cpp:370:11: style: Variable 'F' is assigned a value that is never used. [unreadVariable]
    int F = 3, N = 5;
          ^
machine_learning/ordinary_least_squares_regressor.cpp:370:18: style: Variable 'N' is assigned a value that is never used. [unreadVariable]
    int F = 3, N = 5;
                 ^
math/approximate_pi.cpp:47:23: style: Consider using std::count_if algorithm instead of a raw loop. [useStlAlgorithm]
                    ++count;
                      ^
math/check_factorial.cpp:17:11: style: Checking if unsigned expression 'n' is less than zero. [unsignedLessThanZero]
    if (n <= 0) {
          ^
math/large_number.h:203:19: style: The if condition is the same as the previous if condition [duplicateCondition]
            if (i < this->num_digits())
                  ^
math/large_number.h:201:19: note: First condition
            if (i < this->num_digits())
                  ^
math/large_number.h:203:19: note: Second condition
            if (i < this->num_digits())
                  ^
math/large_number.h:265:29: style: The scope of the variable 'temp' can be reduced. [variableScope]
        uint64_t carry = 0, temp;
                            ^
math/large_number.h:98:9: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
        a++;
        ^
math/fibonacci_sum.cpp:40:33: style: Local variable 'result' shadows outer function [shadowFunction]
    math::fibonacci_sum::matrix result(2, std::vector<uint64_t>(2, 0));
                                ^
math/fibonacci_sum.cpp:76:10: note: Shadowed declaration
uint64_t result(uint64_t n) {
         ^
math/fibonacci_sum.cpp:40:33: note: Shadow variable
    math::fibonacci_sum::matrix result(2, std::vector<uint64_t>(2, 0));
                                ^
math/gcd_iterative_euclidean.cpp:16:19: style:inconclusive: Boolean expression 'num1<=0' is used in bitwise operation. Did you mean '||'? [bitwiseOnBoolean]
    if (num1 <= 0 | num2 <= 0) {
                  ^
math/gcd_iterative_euclidean.cpp:16:19: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
    if (num1 <= 0 | num2 <= 0) {
                  ^
math/gcd_recursive_euclidean.cpp:15:19: style:inconclusive: Boolean expression 'num1<=0' is used in bitwise operation. Did you mean '||'? [bitwiseOnBoolean]
    if (num1 <= 0 | num2 <= 0) {
                  ^
math/gcd_recursive_euclidean.cpp:15:19: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
    if (num1 <= 0 | num2 <= 0) {
                  ^
math/gcd_recursive_euclidean.cpp:30:14: warning: Identical condition 'num1==num2', second condition is always false [identicalConditionAfterEarlyExit]
    if (num1 == num2)
             ^
math/gcd_recursive_euclidean.cpp:19:14: note: If condition 'num1==num2' is true, the function will return/exit
    if (num1 == num2) {
             ^
math/gcd_recursive_euclidean.cpp:30:14: note: Testing identical condition 'num1==num2'
    if (num1 == num2)
             ^
math/integral_approximation2.cpp:148:21: style: Parameter 'x' can be declared with const [constParameter]
    f = [&](double& x) { return -x * x + 4.0; };
                    ^
math/integral_approximation2.cpp:152:23: style: Parameter 'x' can be declared with const [constParameter]
    pdf = [&](double& x) {
                      ^
math/integral_approximation2.cpp:172:21: style: Parameter 'x' can be declared with const [constParameter]
    f = [&](double& x) { return std::exp(x); };
                    ^
math/integral_approximation2.cpp:176:23: style: Parameter 'x' can be declared with const [constParameter]
    pdf = [&](double& x) {
                      ^
math/integral_approximation2.cpp:199:21: style: Parameter 'x' can be declared with const [constParameter]
    f = [&](double& x) { return std::sin(M_PI * x) / (M_PI * x); };
                    ^
math/integral_approximation2.cpp:201:23: style: Parameter 'x' can be declared with const [constParameter]
    pdf = [&](double& x) {
                      ^
math/lcm_sum.cpp:30:23: style: Variable 'j' is assigned a value that is never used. [unreadVariable]
    uint64_t i = 0, j = 0;
                      ^
math/magic_number.cpp:33:11: style: Checking if unsigned expression 'n' is less than zero. [unsignedLessThanZero]
    if (n <= 0) {
          ^
math/ncr_modulo_p.cpp:126:19: warning: Assert statement calls a function which may have desired side effects: 'ncr'. [assertWithSideEffect]
    assert(ncrObj.ncr(52323, 26161, 1000000007) == 224944353);
                  ^
math/ncr_modulo_p.cpp:128:19: warning: Assert statement calls a function which may have desired side effects: 'ncr'. [assertWithSideEffect]
    assert(ncrObj.ncr(6, 2, 5) == 0);
                  ^
math/ncr_modulo_p.cpp:130:19: warning: Assert statement calls a function which may have desired side effects: 'ncr'. [assertWithSideEffect]
    assert(ncrObj.ncr(7, 3, 29) == 6);
                  ^
math/ncr_modulo_p.cpp:43:9: performance: Variable 'fac' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        fac = std::vector<uint64_t>(size);
        ^
math/realtime_stats.cpp:27:1: style: The class 'stats_computer1 < float >' does not have a constructor although it has private member variables. [noConstructor]
class stats_computer1 {
^
math/string_fibonacci.cpp:69:21: style: Variable 'tmp' is assigned a value that is never used. [unreadVariable]
    std::string tmp = "";
                    ^
numerical_methods/babylonian_method.cpp:42:17: style: Variable 'temp' is assigned a value that is never used. [unreadVariable]
    double temp = NAN;             /// Temp variable to x0 and x1
                ^
numerical_methods/bisection_method.cpp:42:14: style: Local variable 'i' shadows outer variable [shadowVariable]
    for (int i = 0; i < MAX_ITERATIONS; i++) {
             ^
numerical_methods/bisection_method.cpp:39:9: note: Shadowed declaration
    int i;
        ^
numerical_methods/bisection_method.cpp:42:14: note: Shadow variable
    for (int i = 0; i < MAX_ITERATIONS; i++) {
             ^
numerical_methods/brent_method_extrema.cpp:51:12: style: The scope of the variable 'fu' can be reduced. [variableScope]
    double fu, fv = f(v);
           ^
numerical_methods/brent_method_extrema.cpp:58:23: style: The scope of the variable 'tolerance2' can be reduced. [variableScope]
    double tolerance, tolerance2;
                      ^
numerical_methods/composite_simpson_rule.cpp:119:38: style: Expression 'log(1 + x)' can be replaced by 'log1p(x)' to avoid loss of precision. [unpreciseMathCall]
double l(double x) { return x + std::log(2 * x + 1); }
                                     ^
numerical_methods/composite_simpson_rule.cpp:74:17: style: Variable 'temp' is assigned a value that is never used. [unreadVariable]
    double temp = NAN;
                ^
numerical_methods/false_position.cpp:103:18: style: The scope of the variable 'b' can be reduced. [variableScope]
    float a = 0, b = 0, i = 0, root = 0;
                 ^
numerical_methods/false_position.cpp:103:20: style: Variable 'b' is assigned a value that is never used. [unreadVariable]
    float a = 0, b = 0, i = 0, root = 0;
                   ^
numerical_methods/false_position.cpp:103:37: style: Variable 'root' is assigned a value that is never used. [unreadVariable]
    float a = 0, b = 0, i = 0, root = 0;
                                    ^
numerical_methods/gaussian_elimination.cpp:60:21: style: Assignment 'x[i][i]=0' is redundant with condition 'x[i][i]==0'. [duplicateConditionalAssign]
            x[i][i] = 0;
                    ^
numerical_methods/gaussian_elimination.cpp:59:21: note: Condition 'x[i][i]==0'
        if (x[i][i] == 0)
                    ^
numerical_methods/gaussian_elimination.cpp:60:21: note: Assignment 'x[i][i]=0' is redundant
            x[i][i] = 0;
                    ^
numerical_methods/golden_search_extrema.cpp:32:12: style: The scope of the variable 'c' can be reduced. [variableScope]
    double c, d;
           ^
numerical_methods/golden_search_extrema.cpp:32:15: style: The scope of the variable 'd' can be reduced. [variableScope]
    double c, d;
              ^
numerical_methods/gram_schmidt.cpp:191:71: error: Out of bounds access in 'b1[j]', if 'b1' size is 1 and 'j' is 2 [containerOutOfBounds]
                numerical_methods::gram_schmidt::dot_product(b1[i], b1[j], 4));
                                                                      ^
numerical_methods/gram_schmidt.cpp:211:71: error: Out of bounds access in 'b2[j]', if 'b2' size is 1 and 'j' is 1 [containerOutOfBounds]
                numerical_methods::gram_schmidt::dot_product(b2[i], b2[j], 2));
                                                                      ^
numerical_methods/gram_schmidt.cpp:231:71: error: Out of bounds access in 'b3[j]', if 'b3' size is 1 and 'j' is 1 [containerOutOfBounds]
                numerical_methods::gram_schmidt::dot_product(b3[i], b3[j], 3));
                                                                      ^
numerical_methods/gram_schmidt.cpp:185:17: style: Variable 'dot1' is assigned a value that is never used. [unreadVariable]
    double dot1 = 0;
                ^
numerical_methods/gram_schmidt.cpp:205:17: style: Variable 'dot2' is assigned a value that is never used. [unreadVariable]
    double dot2 = 0;
                ^
numerical_methods/gram_schmidt.cpp:225:17: style: Variable 'dot3' is assigned a value that is never used. [unreadVariable]
    double dot3 = 0;
                ^
numerical_methods/gram_schmidt.cpp:273:16: style: Variable 'dot' is assigned a value that is never used. [unreadVariable]
    double dot = 0;
               ^
numerical_methods/midpoint_integral_method.cpp:109:38: style: Expression 'log(1 + x)' can be replaced by 'log1p(x)' to avoid loss of precision. [unpreciseMathCall]
double l(double x) { return x + std::log(2 * x + 1); }
                                     ^
numerical_methods/midpoint_integral_method.cpp:60:17: style: Variable 'temp' is assigned a value that is never used. [unreadVariable]
    double temp = NAN;
                ^
numerical_methods/newton_raphson_method.cpp:47:46: style: Variable 'm' is assigned a value that is never used. [unreadVariable]
    double z = NAN, c = std::rand() % 100, m = NAN, n = NAN;
                                             ^
numerical_methods/newton_raphson_method.cpp:47:55: style: Variable 'n' is assigned a value that is never used. [unreadVariable]
    double z = NAN, c = std::rand() % 100, m = NAN, n = NAN;
                                                      ^
numerical_methods/qr_eigen_values.cpp:266:14: style: Local variable 'i' shadows outer variable [shadowVariable]
    for (int i = 0; i < rows; i++) {
             ^
numerical_methods/qr_eigen_values.cpp:262:9: note: Shadowed declaration
    int i, rows = mat_size, columns = mat_size;
        ^
numerical_methods/qr_eigen_values.cpp:266:14: note: Shadow variable
    for (int i = 0; i < rows; i++) {
             ^
numerical_methods/successive_approximation.cpp:21:18: style: The scope of the variable 'x2' can be reduced. [variableScope]
    float y, x1, x2, x3, sum, s, a, f1, f2, gd;
                 ^
numerical_methods/successive_approximation.cpp:21:26: style: The scope of the variable 'sum' can be reduced. [variableScope]
    float y, x1, x2, x3, sum, s, a, f1, f2, gd;
                         ^
numerical_methods/successive_approximation.cpp:27:9: error: Uninitialized variable: y [uninitvar]
        y++;
        ^
numerical_methods/successive_approximation.cpp:12:40: error: Uninitialized variable: y [uninitvar]
static float eq(float y) { return (3 * y) - cos(y) - 2; }
                                       ^
numerical_methods/successive_approximation.cpp:25:18: note: Calling function 'eq', 1st argument 'y' value is <Uninit>
        sum = eq(y);
                 ^
numerical_methods/successive_approximation.cpp:12:40: note: Uninitialized variable: y
static float eq(float y) { return (3 * y) - cos(y) - 2; }
                                       ^
numerical_methods/successive_approximation.cpp:25:18: error: Uninitialized variable: y [uninitvar]
        sum = eq(y);
                 ^
numerical_methods/successive_approximation.cpp:21:22: style: Unused variable: x3 [unusedVariable]
    float y, x1, x2, x3, sum, s, a, f1, f2, gd;
                     ^
numerical_methods/successive_approximation.cpp:21:31: style: Unused variable: s [unusedVariable]
    float y, x1, x2, x3, sum, s, a, f1, f2, gd;
                              ^
numerical_methods/successive_approximation.cpp:21:34: style: Unused variable: a [unusedVariable]
    float y, x1, x2, x3, sum, s, a, f1, f2, gd;
                                 ^
numerical_methods/successive_approximation.cpp:21:37: style: Unused variable: f1 [unusedVariable]
    float y, x1, x2, x3, sum, s, a, f1, f2, gd;
                                    ^
numerical_methods/successive_approximation.cpp:21:41: style: Unused variable: f2 [unusedVariable]
    float y, x1, x2, x3, sum, s, a, f1, f2, gd;
                                        ^
numerical_methods/successive_approximation.cpp:21:45: style: Unused variable: gd [unusedVariable]
    float y, x1, x2, x3, sum, s, a, f1, f2, gd;
                                            ^
operations_on_datastructures/circular_linked_list.cpp:259:14: warning: Assert statement calls a function which may have desired side effects: 'values'. [assertWithSideEffect]
    assert(a.values() == res);
             ^
operations_on_datastructures/circular_linked_list.cpp:276:14: warning: Assert statement calls a function which may have desired side effects: 'values'. [assertWithSideEffect]
    assert(a.values() == res);
             ^
operations_on_datastructures/circular_linked_list.cpp:292:14: warning: Assert statement calls a function which may have desired side effects: 'values'. [assertWithSideEffect]
    assert(a.values() == res);
             ^
operations_on_datastructures/circular_linked_list.cpp:308:14: warning: Assert statement calls a function which may have desired side effects: 'values'. [assertWithSideEffect]
    assert(a.values(start) == res);
             ^
operations_on_datastructures/circular_linked_list.cpp:323:14: warning: Assert statement calls a function which may have desired side effects: 'values'. [assertWithSideEffect]
    assert(a.values() == res);
             ^
operations_on_datastructures/circular_linked_list.cpp:196:10: style:inconclusive: Technically the member function 'operations_on_datastructures::circular_linked_list::CircularLinkedList::print' can be const. [functionConst]
    void print(Node* root) {
         ^
operations_on_datastructures/circular_linked_list.cpp:223:26: style:inconclusive: Technically the member function 'operations_on_datastructures::circular_linked_list::CircularLinkedList::values' can be const. [functionConst]
    std::vector<int64_t> values(Node* root) {
                         ^
operations_on_datastructures/inorder_successor_of_bst.cpp:233:10: performance:inconclusive: Technically the member function 'TestCases::log < const char * >' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void log(T msg) {
         ^
operations_on_datastructures/inorder_successor_of_bst.cpp:233:10: note: Technically the member function 'TestCases::log < const char * >' can be static (but you may consider moving to unnamed namespace).
    void log(T msg) {
         ^
operations_on_datastructures/inorder_successor_of_bst.cpp:233:10: note: Technically the member function 'TestCases::log < const char * >' can be static (but you may consider moving to unnamed namespace).
    void log(T msg) {
         ^
operations_on_datastructures/inorder_successor_of_bst.cpp:157:14: style: Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]
        root = Insert(root, values);
             ^
operations_on_datastructures/reverse_binary_tree.cpp:102:41: warning: Class 'BinaryTree' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
    explicit BinaryTree(int64_t data) { root = new Node(data); }
                                        ^
operations_on_datastructures/reverse_binary_tree.cpp:102:41: warning: Class 'BinaryTree' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
    explicit BinaryTree(int64_t data) { root = new Node(data); }
                                        ^
operations_on_datastructures/reverse_binary_tree.cpp:106:30: warning: Possible leak in public function. The pointer 'root' is not deallocated before it is allocated. [publicAllocationError]
    void add(int64_t data) { root = insert(data, root); }
                             ^
operations_on_datastructures/reverse_binary_tree.cpp:54:11: style: Class 'BinaryTree' is unsafe, 'BinaryTree::root' can leak by wrong usage. [unsafeClassCanLeak]
    Node* root;  ///< Pointer to root node of Binary Tree
          ^
operations_on_datastructures/selectionsortlinkedlist.cpp:9:5: style: Class 'node' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    node(int d) {
    ^
operations_on_datastructures/selectionsortlinkedlist.cpp:39:13: warning: Possible null pointer dereference: t [nullPointer]
        if (t->link == NULL)
            ^
operations_on_datastructures/selectionsortlinkedlist.cpp:28:15: note: Assignment 't=NULL', assigned value is 0
    node *t = NULL;
              ^
operations_on_datastructures/selectionsortlinkedlist.cpp:34:18: note: Assuming condition is false
        if (head == NULL) {
                 ^
operations_on_datastructures/selectionsortlinkedlist.cpp:39:13: note: Null pointer dereference
        if (t->link == NULL)
            ^
operations_on_datastructures/trie_multiple_search.cpp:433:18: warning: Assert statement calls a function which may have desired side effects: 'SearchPresence'. [assertWithSideEffect]
    assert(root->SearchPresence("vvvv"));
                 ^
operations_on_datastructures/trie_multiple_search.cpp:438:19: warning: Assert statement calls a function which may have desired side effects: 'SearchPresence'. [assertWithSideEffect]
    assert(!root->SearchPresence("vvvv"));
                  ^
operations_on_datastructures/trie_multiple_search.cpp:54:9: performance: Variable 'english' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        english = node.english;
        ^
operations_on_datastructures/trie_multiple_search.cpp:69:20: performance:inconclusive: Technically the member function 'operations_on_datastructures::trie_operations::Tnode::numberOfChildren' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    inline uint8_t numberOfChildren(Tnode *node) {
                   ^
operations_on_datastructures/trie_multiple_search.cpp:86:10: performance:inconclusive: Technically the member function 'operations_on_datastructures::trie_operations::Tnode::SelectionTop_3' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void SelectionTop_3(
         ^
operations_on_datastructures/trie_multiple_search.cpp:317:13: note: Technically the member function 'operations_on_datastructures::trie_operations::Tnode::SelectionTop_3' can be static (but you may consider moving to unnamed namespace).
void Tnode::SelectionTop_3(
            ^
operations_on_datastructures/trie_multiple_search.cpp:86:10: note: Technically the member function 'operations_on_datastructures::trie_operations::Tnode::SelectionTop_3' can be static (but you may consider moving to unnamed namespace).
    void SelectionTop_3(
         ^
operations_on_datastructures/trie_multiple_search.cpp:106:9: style: The scope of the variable 'letter_index' can be reduced. [variableScope]
    int letter_index = 0;
        ^
operations_on_datastructures/trie_multiple_search.cpp:219:9: style: The scope of the variable 'letter_index' can be reduced. [variableScope]
    int letter_index = 0;
        ^
operations_on_datastructures/trie_multiple_search.cpp:274:9: style: The scope of the variable 'letter_index' can be reduced. [variableScope]
    int letter_index = 0;
        ^
operations_on_datastructures/trie_multiple_search.cpp:368:9: style: The scope of the variable 'letter_index' can be reduced. [variableScope]
    int letter_index = 0;
        ^
operations_on_datastructures/trie_multiple_search.cpp:106:22: style: Variable 'letter_index' is assigned a value that is never used. [unreadVariable]
    int letter_index = 0;
                     ^
operations_on_datastructures/trie_multiple_search.cpp:219:22: style: Variable 'letter_index' is assigned a value that is never used. [unreadVariable]
    int letter_index = 0;
                     ^
operations_on_datastructures/trie_multiple_search.cpp:274:22: style: Variable 'letter_index' is assigned a value that is never used. [unreadVariable]
    int letter_index = 0;
                     ^
operations_on_datastructures/trie_multiple_search.cpp:368:22: style: Variable 'letter_index' is assigned a value that is never used. [unreadVariable]
    int letter_index = 0;
                     ^
operations_on_datastructures/union_of_two_arrays.cpp:56:18: style: Variable 'next' is assigned a value that is never used. [unreadVariable]
    int32_t next = 0;  ///< Integer to store value of the next element
                 ^
others/decimal_to_binary.cpp:12:9: style: The scope of the variable 'remainder' can be reduced. [variableScope]
    int remainder, binary = 0, var = 1;
        ^
others/iterative_tree_traversals.cpp:71:26: performance:inconclusive: Technically the member function 'others::iterative_tree_traversals::BinaryTree::preOrderIterative' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    std::vector<int64_t> preOrderIterative(
                         ^
others/iterative_tree_traversals.cpp:102:34: note: Technically the member function 'others::iterative_tree_traversals::BinaryTree::preOrderIterative' can be static (but you may consider moving to unnamed namespace).
std::vector<int64_t> BinaryTree::preOrderIterative(Node *root) {
                                 ^
others/iterative_tree_traversals.cpp:71:26: note: Technically the member function 'others::iterative_tree_traversals::BinaryTree::preOrderIterative' can be static (but you may consider moving to unnamed namespace).
    std::vector<int64_t> preOrderIterative(
                         ^
others/iterative_tree_traversals.cpp:74:26: performance:inconclusive: Technically the member function 'others::iterative_tree_traversals::BinaryTree::postOrderIterative' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    std::vector<int64_t> postOrderIterative(
                         ^
others/iterative_tree_traversals.cpp:132:34: note: Technically the member function 'others::iterative_tree_traversals::BinaryTree::postOrderIterative' can be static (but you may consider moving to unnamed namespace).
std::vector<int64_t> BinaryTree::postOrderIterative(Node *root) {
                                 ^
others/iterative_tree_traversals.cpp:74:26: note: Technically the member function 'others::iterative_tree_traversals::BinaryTree::postOrderIterative' can be static (but you may consider moving to unnamed namespace).
    std::vector<int64_t> postOrderIterative(
                         ^
others/iterative_tree_traversals.cpp:77:26: performance:inconclusive: Technically the member function 'others::iterative_tree_traversals::BinaryTree::inOrderIterative' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    std::vector<int64_t> inOrderIterative(
                         ^
others/iterative_tree_traversals.cpp:164:34: note: Technically the member function 'others::iterative_tree_traversals::BinaryTree::inOrderIterative' can be static (but you may consider moving to unnamed namespace).
std::vector<int64_t> BinaryTree::inOrderIterative(Node *root) {
                                 ^
others/iterative_tree_traversals.cpp:77:26: note: Technically the member function 'others::iterative_tree_traversals::BinaryTree::inOrderIterative' can be static (but you may consider moving to unnamed namespace).
    std::vector<int64_t> inOrderIterative(
                         ^
others/matrix_exponentiation.cpp:131:11: style: Unused variable: j [unusedVariable]
    ll i, j, x;
          ^
probability/windowed_median.cpp:229:18: style: Local variable 'i' shadows outer variable [shadowVariable]
        for (int i = 0; i < n; i++) {
                 ^
probability/windowed_median.cpp:220:14: note: Shadowed declaration
    for (int i = 8; i < 100; i++) {
             ^
probability/windowed_median.cpp:229:18: note: Shadow variable
        for (int i = 0; i < n; i++) {
                 ^
range_queries/fenwick_tree.cpp:74:25: warning: Assert statement calls a function which may have desired side effects: 'sum_range'. [assertWithSideEffect]
    assert(fenwick_tree.sum_range(0, 0) == 1);
                        ^
range_queries/fenwick_tree.cpp:75:25: warning: Assert statement calls a function which may have desired side effects: 'sum_range'. [assertWithSideEffect]
    assert(fenwick_tree.sum_range(0, 1) == 3);
                        ^
range_queries/fenwick_tree.cpp:76:25: warning: Assert statement calls a function which may have desired side effects: 'sum_range'. [assertWithSideEffect]
    assert(fenwick_tree.sum_range(0, 2) == 6);
                        ^
range_queries/fenwick_tree.cpp:78:25: warning: Assert statement calls a function which may have desired side effects: 'sum_range'. [assertWithSideEffect]
    assert(fenwick_tree.sum_range(0, 0) == 6);
                        ^
range_queries/fenwick_tree.cpp:79:25: warning: Assert statement calls a function which may have desired side effects: 'sum_range'. [assertWithSideEffect]
    assert(fenwick_tree.sum_range(0, 1) == 8);
                        ^
range_queries/fenwick_tree.cpp:80:25: warning: Assert statement calls a function which may have desired side effects: 'sum_range'. [assertWithSideEffect]
    assert(fenwick_tree.sum_range(0, 2) == 11);
                        ^
range_queries/fenwick_tree.cpp:22:16: performance:inconclusive: Technically the member function 'FenwickTree::offset' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    inline int offset(int x) { return (x & (-x)); }
               ^
range_queries/fenwick_tree.cpp:22:42: style: Opposite expression on both sides of '&'. [oppositeExpression]
    inline int offset(int x) { return (x & (-x)); }
                                         ^
range_queries/fenwick_tree.cpp:70:11: style: Variable 'n' is assigned a value that is never used. [unreadVariable]
    int n = 5;
          ^
range_queries/heavy_light_decomposition.cpp:274:5: performance:inconclusive: Technically the member function 'SG < int64_t >::combine' can be static (but you may consider moving to unnamed namespace). [functionStatic]
  X combine(X lhs, X rhs) { return lhs + rhs; }
    ^
range_queries/heavy_light_decomposition.cpp:200:8: style:inconclusive: Technically the member function 'Tree < int64_t >::lift' can be const. [functionConst]
  void lift(int *const p, int dist) {
       ^
range_queries/mo.cpp:29:23: style: Variable 'k' is assigned a value that is never used. [unreadVariable]
    int n, t, i, j, k = 0;
                      ^
range_queries/mo.cpp:29:18: style: Unused variable: j [unusedVariable]
    int n, t, i, j, k = 0;
                 ^
range_queries/persistent_seg_tree_lazy_prop.cpp:255:14: style:inconclusive: Technically the member function 'range_queries::perSegTree::size' can be const. [functionConst]
    uint32_t size()  // returns the number of segment trees (versions) , the
             ^
range_queries/sparse_table.cpp:57:9: style: The scope of the variable 'curLen' can be reduced. [variableScope]
    int curLen = 0;
        ^
range_queries/sparse_table.cpp:57:16: style: Variable 'curLen' is assigned a value that is never used. [unreadVariable]
    int curLen = 0;
               ^
search/exponential_search.cpp:35:52: style: The scope of the variable 'middle_index' can be reduced. [variableScope]
    int32_t lower_index(0), upper_index(size - 1), middle_index;
                                                   ^
search/fibonacci_search.cpp:38:22: style: The scope of the variable 'index' can be reduced. [variableScope]
    int offset = -1, index;
                     ^
search/fibonacci_search.cpp:74:19: style: The scope of the variable 'rand_value' can be reduced. [variableScope]
    int rand_num, rand_value, index, num_tests = 1000;
                  ^
search/fibonacci_search.cpp:74:31: style: The scope of the variable 'index' can be reduced. [variableScope]
    int rand_num, rand_value, index, num_tests = 1000;
                              ^
search/fibonacci_search.cpp:98:19: style: The scope of the variable 'rand_value' can be reduced. [variableScope]
    int rand_num, rand_value, index, real_value, num_tests = 10000;
                  ^
search/fibonacci_search.cpp:98:31: style: The scope of the variable 'index' can be reduced. [variableScope]
    int rand_num, rand_value, index, real_value, num_tests = 10000;
                              ^
search/fibonacci_search.cpp:84:13: warning: Return value of std::remove() ignored. Elements remain in container. [uselessCallsRemove]
            std::remove(arr.begin(), arr.end(), rand_value);
            ^
search/hash_search.cpp:124:12: error: Uninitialized variable: key [uninitvar]
    while (key != -1) {
           ^
search/sublist_search.cpp:161:10: performance:inconclusive: Technically the member function 'TestCases::log < const char * >' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void log(T msg) {
         ^
search/sublist_search.cpp:161:10: note: Technically the member function 'TestCases::log < const char * >' can be static (but you may consider moving to unnamed namespace).
    void log(T msg) {
         ^
search/sublist_search.cpp:161:10: note: Technically the member function 'TestCases::log < const char * >' can be static (but you may consider moving to unnamed namespace).
    void log(T msg) {
         ^
sorting/bogo_sort.cpp:82:11: style: Consider using std::fill or std::generate algorithm instead of a raw loop. [useStlAlgorithm]
        x = std::rand() % 100;
          ^
sorting/bogo_sort.cpp:93:11: style: Consider using std::fill or std::generate algorithm instead of a raw loop. [useStlAlgorithm]
        x = std::rand() % 100;
          ^
sorting/count_inversions.cpp:133:14: style: The scope of the variable 'mid' can be reduced. [variableScope]
    uint32_t mid = 0, inv_count = 0;
             ^
sorting/count_inversions.cpp:133:18: style: Variable 'mid' is assigned a value that is never used. [unreadVariable]
    uint32_t mid = 0, inv_count = 0;
                 ^
sorting/counting_sort.cpp:31:33: error: Memory is allocated but not initialized: Count [uninitdata]
    for (int i = 0; i < N; i++) Count[Arr[i] - min]++;
                                ^
sorting/counting_sort_string.cpp:10:14: style: Local variable 'i' shadows outer variable [shadowVariable]
    for (int i = 0; i < 256; i++) count[i] = 0;
             ^
sorting/counting_sort_string.cpp:9:21: note: Shadowed declaration
    int count[256], i;
                    ^
sorting/counting_sort_string.cpp:10:14: note: Shadow variable
    for (int i = 0; i < 256; i++) count[i] = 0;
             ^
sorting/counting_sort_string.cpp:17:15: error: Out of bounds access in expression 'output[count[arr[i]]-1]' because 'output' is empty. [containerOutOfBounds]
        output[count[arr[i]] - 1] = arr[i];
              ^
sorting/counting_sort_string.cpp:21:45: error: Out of bounds access in expression 'output[i]' because 'output' is empty. [containerOutOfBounds]
    for (i = 0; arr[i]; ++i) arr[i] = output[i];
                                            ^
sorting/gnome_sort.cpp:117:11: style: Consider using std::fill or std::generate algorithm instead of a raw loop. [useStlAlgorithm]
        a = float(std::rand() % 1000 - 500) / 100.f;
          ^
sorting/merge_insertion_sort.cpp:38:19: style: The scope of the variable 'j' can be reduced. [variableScope]
    size_t i = 0, j = 0;
                  ^
sorting/merge_insertion_sort.cpp:38:21: style: Variable 'j' is assigned a value that is never used. [unreadVariable]
    size_t i = 0, j = 0;
                    ^
sorting/quick_sort_3.cpp:145:15: style: Consider using std::fill or std::generate algorithm instead of a raw loop. [useStlAlgorithm]
            a = std::rand() % 500 - 250;  // random numbers between -250, 249
              ^
sorting/random_pivot_quick_sort.cpp:189:10: performance:inconclusive: Technically the member function 'TestCases::log < const char * >' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void log(T msg) {
         ^
sorting/random_pivot_quick_sort.cpp:189:10: note: Technically the member function 'TestCases::log < const char * >' can be static (but you may consider moving to unnamed namespace).
    void log(T msg) {
         ^
sorting/random_pivot_quick_sort.cpp:189:10: note: Technically the member function 'TestCases::log < const char * >' can be static (but you may consider moving to unnamed namespace).
    void log(T msg) {
         ^
sorting/random_pivot_quick_sort.cpp:136:19: error:inconclusive: Array index -1 is out of bounds. [negativeContainerIndex]
        std::swap(arr[end], arr[randomIndex]);
                  ^
sorting/random_pivot_quick_sort.cpp:138:30: note: Assignment 'pivotIndex=0', assigned value is 0
        int64_t pivotIndex = 0;
                             ^
sorting/random_pivot_quick_sort.cpp:144:48: note: Calling function 'quickSortRP', 3rd argument 'pivotIndex-1' value is -1
            quickSortRP(arr, start, pivotIndex - 1);
                                               ^
sorting/random_pivot_quick_sort.cpp:136:19: note: Negative array index
        std::swap(arr[end], arr[randomIndex]);
                  ^
sorting/slow_sort.cpp:18:9: style: The scope of the variable 'temp' can be reduced. [variableScope]
    int temp;
        ^
sorting/wiggle_sort.cpp:111:11: style: Consider using std::fill or std::generate algorithm instead of a raw loop. [useStlAlgorithm]
        d = float(std::rand() % 1000 - 500) / 100.f;
          ^
data_structures/avltree.cpp:13:9: error: The one definition rule is violated, different classes/structs have the same name 'node' [ctuOneDefinitionRuleViolation]
typedef struct node {
        ^
data_structures/binary_search_tree.cpp:11:1: note: The one definition rule is violated, different classes/structs have the same name 'node'
struct node {
^
data_structures/avltree.cpp:13:9: note: The one definition rule is violated, different classes/structs have the same name 'node'
typedef struct node {
        ^
data_structures/avltree.cpp:13:9: error: The one definition rule is violated, different classes/structs have the same name 'node' [ctuOneDefinitionRuleViolation]
typedef struct node {
        ^
data_structures/circular_queue_using_linked_list.cpp:3:1: note: The one definition rule is violated, different classes/structs have the same name 'node'
struct node {
^
data_structures/avltree.cpp:13:9: note: The one definition rule is violated, different classes/structs have the same name 'node'
typedef struct node {
        ^
data_structures/avltree.cpp:13:9: error: The one definition rule is violated, different classes/structs have the same name 'node' [ctuOneDefinitionRuleViolation]
typedef struct node {
        ^
data_structures/cll/cll.h:12:1: note: The one definition rule is violated, different classes/structs have the same name 'node'
struct node {
^
data_structures/avltree.cpp:13:9: note: The one definition rule is violated, different classes/structs have the same name 'node'
typedef struct node {
        ^
data_structures/avltree.cpp:13:9: error: The one definition rule is violated, different classes/structs have the same name 'node' [ctuOneDefinitionRuleViolation]
typedef struct node {
        ^
data_structures/doubly_linked_list.cpp:5:1: note: The one definition rule is violated, different classes/structs have the same name 'node'
struct node {
^
data_structures/avltree.cpp:13:9: note: The one definition rule is violated, different classes/structs have the same name 'node'
typedef struct node {
        ^
data_structures/dsu_path_compression.cpp:33:1: error: The one definition rule is violated, different classes/structs have the same name 'dsu' [ctuOneDefinitionRuleViolation]
class dsu {
^
data_structures/dsu_union_rank.cpp:34:1: note: The one definition rule is violated, different classes/structs have the same name 'dsu'
class dsu {
^
data_structures/dsu_path_compression.cpp:33:1: note: The one definition rule is violated, different classes/structs have the same name 'dsu'
class dsu {
^
data_structures/avltree.cpp:13:9: error: The one definition rule is violated, different classes/structs have the same name 'node' [ctuOneDefinitionRuleViolation]
typedef struct node {
        ^
data_structures/queue_using_linked_list.cpp:4:1: note: The one definition rule is violated, different classes/structs have the same name 'node'
struct node {
^
data_structures/avltree.cpp:13:9: note: The one definition rule is violated, different classes/structs have the same name 'node'
typedef struct node {
        ^
data_structures/avltree.cpp:13:9: error: The one definition rule is violated, different classes/structs have the same name 'node' [ctuOneDefinitionRuleViolation]
typedef struct node {
        ^
data_structures/rb_tree.cpp:5:1: note: The one definition rule is violated, different classes/structs have the same name 'node'
struct node
^
data_structures/avltree.cpp:13:9: note: The one definition rule is violated, different classes/structs have the same name 'node'
typedef struct node {
        ^
data_structures/avltree.cpp:13:9: error: The one definition rule is violated, different classes/structs have the same name 'node' [ctuOneDefinitionRuleViolation]
typedef struct node {
        ^
data_structures/stack_using_linked_list.cpp:3:1: note: The one definition rule is violated, different classes/structs have the same name 'node'
struct node {
^
data_structures/avltree.cpp:13:9: note: The one definition rule is violated, different classes/structs have the same name 'node'
typedef struct node {
        ^
data_structures/avltree.cpp:13:9: error: The one definition rule is violated, different classes/structs have the same name 'node' [ctuOneDefinitionRuleViolation]
typedef struct node {
        ^
data_structures/tree.cpp:5:1: note: The one definition rule is violated, different classes/structs have the same name 'node'
struct node {
^
data_structures/avltree.cpp:13:9: note: The one definition rule is violated, different classes/structs have the same name 'node'
typedef struct node {
        ^
dynamic_programming/bellman_ford.cpp:13:1: error: The one definition rule is violated, different classes/structs have the same name 'Graph' [ctuOneDefinitionRuleViolation]
class Graph {
^
dynamic_programming/floyd_warshall.cpp:10:1: note: The one definition rule is violated, different classes/structs have the same name 'Graph'
class Graph {
^
dynamic_programming/bellman_ford.cpp:13:1: note: The one definition rule is violated, different classes/structs have the same name 'Graph'
class Graph {
^
dynamic_programming/bellman_ford.cpp:13:1: error: The one definition rule is violated, different classes/structs have the same name 'Graph' [ctuOneDefinitionRuleViolation]
class Graph {
^
graph/max_flow_with_ford_fulkerson_and_edmond_karp_algo.cpp:18:1: note: The one definition rule is violated, different classes/structs have the same name 'Graph'
class Graph {
^
dynamic_programming/bellman_ford.cpp:13:1: note: The one definition rule is violated, different classes/structs have the same name 'Graph'
class Graph {
^
dynamic_programming/bellman_ford.cpp:13:1: error: The one definition rule is violated, different classes/structs have the same name 'Graph' [ctuOneDefinitionRuleViolation]
class Graph {
^
greedy_algorithms/dijkstra.cpp:7:1: note: The one definition rule is violated, different classes/structs have the same name 'Graph'
class Graph {
^
dynamic_programming/bellman_ford.cpp:13:1: note: The one definition rule is violated, different classes/structs have the same name 'Graph'
class Graph {
^
data_structures/linkedlist_implentation_usingarray.cpp:14:1: error: The one definition rule is violated, different classes/structs have the same name 'Node' [ctuOneDefinitionRuleViolation]
struct Node {
^
operations_on_datastructures/get_size_of_linked_list.cpp:3:1: note: The one definition rule is violated, different classes/structs have the same name 'Node'
class Node {
^
data_structures/linkedlist_implentation_usingarray.cpp:14:1: note: The one definition rule is violated, different classes/structs have the same name 'Node'
struct Node {
^
data_structures/avltree.cpp:13:9: error: The one definition rule is violated, different classes/structs have the same name 'node' [ctuOneDefinitionRuleViolation]
typedef struct node {
        ^
operations_on_datastructures/reverse_a_linked_list_using_recusion.cpp:4:1: note: The one definition rule is violated, different classes/structs have the same name 'node'
struct node {
^
data_structures/avltree.cpp:13:9: note: The one definition rule is violated, different classes/structs have the same name 'node'
typedef struct node {
        ^
data_structures/avltree.cpp:13:9: error: The one definition rule is violated, different classes/structs have the same name 'node' [ctuOneDefinitionRuleViolation]
typedef struct node {
        ^
operations_on_datastructures/selectionsortlinkedlist.cpp:5:1: note: The one definition rule is violated, different classes/structs have the same name 'node'
class node {
^
data_structures/avltree.cpp:13:9: note: The one definition rule is violated, different classes/structs have the same name 'node'
typedef struct node {
        ^
geometry/line_segment_intersection.cpp:12:1: error: The one definition rule is violated, different classes/structs have the same name 'Point' [ctuOneDefinitionRuleViolation]
struct Point {
^
others/smallest_circle.cpp:15:1: note: The one definition rule is violated, different classes/structs have the same name 'Point'
struct Point {
^
geometry/line_segment_intersection.cpp:12:1: note: The one definition rule is violated, different classes/structs have the same name 'Point'
struct Point {
^
operations_on_datastructures/inorder_successor_of_bst.cpp:225:1: error: The one definition rule is violated, different classes/structs have the same name 'TestCases' [ctuOneDefinitionRuleViolation]
class TestCases {
^
search/sublist_search.cpp:153:1: note: The one definition rule is violated, different classes/structs have the same name 'TestCases'
class TestCases {
^
operations_on_datastructures/inorder_successor_of_bst.cpp:225:1: note: The one definition rule is violated, different classes/structs have the same name 'TestCases'
class TestCases {
^
operations_on_datastructures/inorder_successor_of_bst.cpp:225:1: error: The one definition rule is violated, different classes/structs have the same name 'TestCases' [ctuOneDefinitionRuleViolation]
class TestCases {
^
sorting/random_pivot_quick_sort.cpp:181:1: note: The one definition rule is violated, different classes/structs have the same name 'TestCases'
class TestCases {
^
operations_on_datastructures/inorder_successor_of_bst.cpp:225:1: note: The one definition rule is violated, different classes/structs have the same name 'TestCases'
class TestCases {
^
data_structures/tree_234.cpp:637:0: style: The function 'InsertPostMerge' is never used. [unusedFunction]

^
graph/cycle_check_directed_graph.cpp:118:0: style: The function 'addVertices' is never used. [unusedFunction]

^
machine_learning/neural_network.cpp:464:0: style: The function 'batch_predict' is never used. [unusedFunction]

^
math/binary_exponent.cpp:42:0: style: The function 'binExpo_alt' is never used. [unusedFunction]

^
range_queries/heavy_light_decomposition.cpp:167:0: style: The function 'change_root' is never used. [unusedFunction]

^
data_structures/skip_list.cpp:133:0: style: The function 'deleteElement' is never used. [unusedFunction]

^
machine_learning/neural_network.cpp:67:0: style: The function 'dsigmoid' is never used. [unusedFunction]

^
machine_learning/neural_network.cpp:638:0: style: The function 'evaluate_from_csv' is never used. [unusedFunction]

^
data_structures/linkedlist_implentation_usingarray.cpp:42:0: style: The function 'freeNode' is never used. [unusedFunction]

^
ciphers/hill_cipher.cpp:182:0: style: The function 'get_idx_char' is never used. [unusedFunction]

^
range_queries/heavy_light_decomposition.cpp:218:0: style: The function 'kth_ancestor' is never used. [unusedFunction]

^
machine_learning/neural_network.cpp:732:0: style: The function 'load_model' is never used. [unusedFunction]

^
cpu_scheduling_algorithms/fcfs_scheduling.cpp:191:0: style: The function 'printResult' is never used. [unusedFunction]

^
machine_learning/neural_network.cpp:652:0: style: The function 'save_model' is never used. [unusedFunction]

^
data_structures/skip_list.cpp:170:0: style: The function 'searchElement' is never used. [unusedFunction]

^
range_queries/heavy_light_decomposition.cpp:329:0: style: The function 'set_sret_init' is never used. [unusedFunction]

^
math/power_of_two.cpp:79:0: style: The function 'user_input_test' is never used. [unusedFunction]

^
nofile:0:0: information: Cppcheck cannot find all the include files (use --check-config for details) [missingInclude]

